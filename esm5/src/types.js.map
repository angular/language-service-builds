{"version":3,"file":"types.js","sourceRoot":"","sources":["../../../../../packages/language-service/src/types.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAGH,OAAO,EAAC,WAAW,EAAqH,MAAM,6CAA6C,CAAC;AAE5L,OAAO,EACL,WAAW,EAWZ,CAAC;AAiOF;;;;GAIG;AACH,MAAM,CAAN,IAAY,cAGX;AAHD,WAAY,cAAc;IACxB,qDAAK,CAAA;IACL,yDAAO,CAAA;AACT,CAAC,EAHW,cAAc,KAAd,cAAc,QAGzB","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {CompileDirectiveMetadata, CompileMetadataResolver, CompilePipeSummary, NgAnalyzedModules, StaticSymbol} from '@angular/compiler';\nimport {BuiltinType, DeclarationKind, Definition, PipeInfo, Pipes, Signature, Span, Symbol, SymbolDeclaration, SymbolQuery, SymbolTable} from '@angular/compiler-cli/src/language_services';\n\nexport {\n  BuiltinType,\n  DeclarationKind,\n  Definition,\n  PipeInfo,\n  Pipes,\n  Signature,\n  Span,\n  Symbol,\n  SymbolDeclaration,\n  SymbolQuery,\n  SymbolTable\n};\n\n/**\n * The information `LanguageService` needs from the `LanguageServiceHost` to describe the content of\n * a template and the language context the template is in.\n *\n * A host interface; see `LanguageSeriviceHost`.\n *\n * @experimental\n */\nexport interface TemplateSource {\n  /**\n   * The source of the template.\n   */\n  readonly source: string;\n\n  /**\n   * The version of the source. As files are modified the version should change. That is, if the\n   * `LanguageService` requesting template infomration for a source file and that file has changed\n   * since the last time the host was asked for the file then this version string should be\n   * different. No assumptions are made about the format of this string.\n   *\n   * The version can change more often than the source but should not change less often.\n   */\n  readonly version: string;\n\n  /**\n   * The span of the template within the source file.\n   */\n  readonly span: Span;\n\n  /**\n   * A static symbol for the template's component.\n   */\n  readonly type: StaticSymbol;\n\n  /**\n   * The `SymbolTable` for the members of the component.\n   */\n  readonly members: SymbolTable;\n\n  /**\n   * A `SymbolQuery` for the context of the template.\n   */\n  readonly query: SymbolQuery;\n}\n\n/**\n * A sequence of template sources.\n *\n * A host type; see `LanguageSeriviceHost`.\n *\n * @experimental\n */\nexport type TemplateSources = TemplateSource[] | undefined;\n\n\n/**\n * Error information found getting declaration information\n *\n * A host type; see `LanguageServiceHost`.\n *\n * @experimental\n */\nexport interface DeclarationError {\n  /**\n   * The span of the error in the declaration's module.\n   */\n  readonly span: Span;\n\n  /**\n   * The message to display describing the error or a chain\n   * of messages.\n   */\n  readonly message: string|DiagnosticMessageChain;\n}\n\n/**\n * Information about the component declarations.\n *\n * A file might contain a declaration without a template because the file contains only\n * templateUrl references. However, the compoennt declaration might contain errors that\n * need to be reported such as the template string is missing or the component is not\n * declared in a module. These error should be reported on the declaration, not the\n * template.\n *\n * A host type; see `LanguageSeriviceHost`.\n *\n * @experimental\n */\nexport interface Declaration {\n  /**\n   * The static symbol of the compponent being declared.\n   */\n  readonly type: StaticSymbol;\n\n  /**\n   * The span of the declaration annotation reference (e.g. the 'Component' or 'Directive'\n   * reference).\n   */\n  readonly declarationSpan: Span;\n\n  /**\n   * Reference to the compiler directive metadata for the declaration.\n   */\n  readonly metadata?: CompileDirectiveMetadata;\n\n  /**\n   * Error reported trying to get the metadata.\n   */\n  readonly errors: DeclarationError[];\n}\n\n/**\n * A sequence of declarations.\n *\n * A host type; see `LanguageSeriviceHost`.\n *\n * @experimental\n */\nexport type Declarations = Declaration[];\n\n/**\n * The host for a `LanguageService`. This provides all the `LanguageService` requires to respond\n * to\n * the `LanguageService` requests.\n *\n * This interface describes the requirements of the `LanguageService` on its host.\n *\n * The host interface is host language agnostic.\n *\n * Adding optional member to this interface or any interface that is described as a\n * `LanguageServiceHost` interface is not considered a breaking change as defined by SemVer.\n * Removing a method or changing a member from required to optional will also not be considered a\n * breaking change.\n *\n * If a member is deprecated it will be changed to optional in a minor release before it is\n * removed in a major release.\n *\n * Adding a required member or changing a method's parameters, is considered a breaking change and\n * will only be done when breaking changes are allowed. When possible, a new optional member will\n * be added and the old member will be deprecated. The new member will then be made required in\n * and the old member will be removed only when breaking chnages are allowed.\n *\n * While an interface is marked as experimental breaking-changes will be allowed between minor\n * releases. After an interface is marked as stable breaking-changes will only be allowed between\n * major releases. No breaking changes are allowed between patch releases.\n *\n * @experimental\n */\nexport interface LanguageServiceHost {\n  /**\n   * The resolver to use to find compiler metadata.\n   */\n  readonly resolver: CompileMetadataResolver;\n\n  /**\n   * Returns the template information for templates in `fileName` at the given location. If\n   * `fileName` refers to a template file then the `position` should be ignored. If the `position`\n   * is not in a template literal string then this method should return `undefined`.\n   */\n  getTemplateAt(fileName: string, position: number): TemplateSource|undefined;\n\n  /**\n   * Return the template source information for all templates in `fileName` or for `fileName` if\n   * it\n   * is a template file.\n   */\n  getTemplates(fileName: string): TemplateSources;\n\n  /**\n   * Returns the Angular declarations in the given file.\n   */\n  getDeclarations(fileName: string): Declarations;\n\n  /**\n   * Return a summary of all Angular modules in the project.\n   */\n  getAnalyzedModules(): NgAnalyzedModules;\n\n  /**\n   * Return a list all the template files referenced by the project.\n   */\n  getTemplateReferences(): string[];\n}\n\n/**\n * An item of the completion result to be displayed by an editor.\n *\n * A `LanguageService` interface.\n *\n * @experimental\n */\nexport interface Completion {\n  /**\n   * The kind of comletion.\n   */\n  kind: DeclarationKind;\n\n  /**\n   * The name of the completion to be displayed\n   */\n  name: string;\n\n  /**\n   * The key to use to sort the completions for display.\n   */\n  sort: string;\n}\n\n/**\n * A sequence of completions.\n *\n * @experimental\n */\nexport type Completions = Completion[] | undefined;\n\n/**\n * A file and span.\n */\nexport interface Location {\n  fileName: string;\n  span: Span;\n}\n\n/**\n * The kind of diagnostic message.\n *\n * @experimental\n */\nexport enum DiagnosticKind {\n  Error,\n  Warning,\n}\n\n/**\n * A template diagnostics message chain. This is similar to the TypeScript\n * DiagnosticMessageChain. The messages are intended to be formatted as separate\n * sentence fragments and indented.\n *\n * For compatiblity previous implementation, the values are expected to override\n * toString() to return a formatted message.\n *\n * @experimental\n */\nexport interface DiagnosticMessageChain {\n  /**\n   * The text of the diagnostic message to display.\n   */\n  message: string;\n\n  /**\n   * The next message in the chain.\n   */\n  next?: DiagnosticMessageChain;\n}\n\n/**\n * An template diagnostic message to display.\n *\n * @experimental\n */\nexport interface Diagnostic {\n  /**\n   * The kind of diagnostic message\n   */\n  kind: DiagnosticKind;\n\n  /**\n   * The source span that should be highlighted.\n   */\n  span: Span;\n\n  /**\n   * The text of the diagnostic message to display or a chain of messages.\n   */\n  message: string|DiagnosticMessageChain;\n}\n\n/**\n * A sequence of diagnostic message.\n *\n * @experimental\n */\nexport type Diagnostics = Diagnostic[];\n\n/**\n * A section of hover text. If the text is code then langauge should be provided.\n * Otherwise the text is assumed to be Markdown text that will be sanitized.\n */\nexport interface HoverTextSection {\n  /**\n   * Source code or markdown text describing the symbol a the hover location.\n   */\n  readonly text: string;\n\n  /**\n   * The langauge of the source if `text` is a souce code fragment.\n   */\n  readonly language?: string;\n}\n\n/**\n * Hover infomration for a symbol at the hover location.\n */\nexport interface Hover {\n  /**\n   * The hover text to display for the symbol at the hover location. If the text includes\n   * source code, the section will specify which langauge it should be interpreted as.\n   */\n  readonly text: HoverTextSection[];\n\n  /**\n   * The span of source the hover covers.\n   */\n  readonly span: Span;\n}\n\n/**\n * An instance of an Angular language service created by `createLanguageService()`.\n *\n * The language service returns information about Angular templates that are included in a project\n * as defined by the `LanguageServiceHost`.\n *\n * When a method expects a `fileName` this file can either be source file in the project that\n * contains a template in a string literal or a template file referenced by the project returned\n * by `getTemplateReference()`. All other files will cause the method to return `undefined`.\n *\n * If a method takes a `position`, it is the offset of the UTF-16 code-point relative to the\n * beginning of the file reference by `fileName`.\n *\n * This interface and all interfaces and types marked as `LanguageService` types, describe  a\n * particlar implementation of the Angular language service and is not intented to be\n * implemented. Adding members to the interface will not be considered a breaking change as\n * defined by SemVer.\n *\n * Removing a member or making a member optional, changing a method parameters, or changing a\n * member's type will all be considered a breaking change.\n *\n * While an interface is marked as experimental breaking-changes will be allowed between minor\n * releases. After an interface is marked as stable breaking-changes will only be allowed between\n * major releases. No breaking changes are allowed between patch releases.\n *\n * @experimental\n */\nexport interface LanguageService {\n  /**\n   * Returns a list of all the external templates referenced by the project.\n   */\n  getTemplateReferences(): string[]|undefined;\n\n  /**\n   * Returns a list of all error for all templates in the given file.\n   */\n  getDiagnostics(fileName: string): Diagnostics|undefined;\n\n  /**\n   * Return the completions at the given position.\n   */\n  getCompletionsAt(fileName: string, position: number): Completions|undefined;\n\n  /**\n   * Return the definition location for the symbol at position.\n   */\n  getDefinitionAt(fileName: string, position: number): Definition|undefined;\n\n  /**\n   * Return the hover information for the symbol at position.\n   */\n  getHoverAt(fileName: string, position: number): Hover|undefined;\n\n  /**\n   * Return the pipes that are available at the given position.\n   */\n  getPipesAt(fileName: string, position: number): CompilePipeSummary[];\n}\n"]}