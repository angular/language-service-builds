{"version":3,"file":"expressions.js","sourceRoot":"","sources":["../../../../../packages/language-service/src/expressions.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AST, ASTWithSource, AstPath as AstPathBase, NullAstVisitor, visitAstChildren} from '@angular/compiler';\nimport {AstType} from '@angular/compiler-cli/src/language_services';\n\nimport {BuiltinType, Span, Symbol, SymbolQuery, SymbolTable} from './types';\nimport {inSpan} from './utils';\n\ntype AstPath = AstPathBase<AST>;\n\nfunction findAstAt(ast: AST, position: number, excludeEmpty: boolean = false): AstPath {\n  const path: AST[] = [];\n  const visitor = new class extends NullAstVisitor {\n    visit(ast: AST) {\n      if ((!excludeEmpty || ast.span.start < ast.span.end) && inSpan(position, ast.span)) {\n        path.push(ast);\n        visitAstChildren(ast, this);\n      }\n    }\n  };\n\n  // We never care about the ASTWithSource node and its visit() method calls its ast's visit so\n  // the visit() method above would never see it.\n  if (ast instanceof ASTWithSource) {\n    ast = ast.ast;\n  }\n\n  visitor.visit(ast);\n\n  return new AstPathBase<AST>(path, position);\n}\n\nexport function getExpressionCompletions(\n    scope: SymbolTable, ast: AST, position: number, query: SymbolQuery): Symbol[]|undefined {\n  const path = findAstAt(ast, position);\n  if (path.empty) return undefined;\n  const tail = path.tail !;\n  let result: SymbolTable|undefined = scope;\n\n  function getType(ast: AST): Symbol { return new AstType(scope, query, {}).getType(ast); }\n\n  // If the completion request is in a not in a pipe or property access then the global scope\n  // (that is the scope of the implicit receiver) is the right scope as the user is typing the\n  // beginning of an expression.\n  tail.visit({\n    visitBinary(ast) {},\n    visitChain(ast) {},\n    visitConditional(ast) {},\n    visitFunctionCall(ast) {},\n    visitImplicitReceiver(ast) {},\n    visitInterpolation(ast) { result = undefined; },\n    visitKeyedRead(ast) {},\n    visitKeyedWrite(ast) {},\n    visitLiteralArray(ast) {},\n    visitLiteralMap(ast) {},\n    visitLiteralPrimitive(ast) {},\n    visitMethodCall(ast) {},\n    visitPipe(ast) {\n      if (position >= ast.exp.span.end &&\n          (!ast.args || !ast.args.length || position < (<AST>ast.args[0]).span.start)) {\n        // We are in a position a pipe name is expected.\n        result = query.getPipes();\n      }\n    },\n    visitPrefixNot(ast) {},\n    visitNonNullAssert(ast) {},\n    visitPropertyRead(ast) {\n      const receiverType = getType(ast.receiver);\n      result = receiverType ? receiverType.members() : scope;\n    },\n    visitPropertyWrite(ast) {\n      const receiverType = getType(ast.receiver);\n      result = receiverType ? receiverType.members() : scope;\n    },\n    visitQuote(ast) {\n      // For a quote, return the members of any (if there are any).\n      result = query.getBuiltinType(BuiltinType.Any).members();\n    },\n    visitSafeMethodCall(ast) {\n      const receiverType = getType(ast.receiver);\n      result = receiverType ? receiverType.members() : scope;\n    },\n    visitSafePropertyRead(ast) {\n      const receiverType = getType(ast.receiver);\n      result = receiverType ? receiverType.members() : scope;\n    },\n  });\n\n  return result && result.values();\n}\n\nexport function getExpressionSymbol(\n    scope: SymbolTable, ast: AST, position: number,\n    query: SymbolQuery): {symbol: Symbol, span: Span}|undefined {\n  const path = findAstAt(ast, position, /* excludeEmpty */ true);\n  if (path.empty) return undefined;\n  const tail = path.tail !;\n\n  function getType(ast: AST): Symbol { return new AstType(scope, query, {}).getType(ast); }\n\n  let symbol: Symbol|undefined = undefined;\n  let span: Span|undefined = undefined;\n\n  // If the completion request is in a not in a pipe or property access then the global scope\n  // (that is the scope of the implicit receiver) is the right scope as the user is typing the\n  // beginning of an expression.\n  tail.visit({\n    visitBinary(ast) {},\n    visitChain(ast) {},\n    visitConditional(ast) {},\n    visitFunctionCall(ast) {},\n    visitImplicitReceiver(ast) {},\n    visitInterpolation(ast) {},\n    visitKeyedRead(ast) {},\n    visitKeyedWrite(ast) {},\n    visitLiteralArray(ast) {},\n    visitLiteralMap(ast) {},\n    visitLiteralPrimitive(ast) {},\n    visitMethodCall(ast) {\n      const receiverType = getType(ast.receiver);\n      symbol = receiverType && receiverType.members().get(ast.name);\n      span = ast.span;\n    },\n    visitPipe(ast) {\n      if (position >= ast.exp.span.end &&\n          (!ast.args || !ast.args.length || position < (<AST>ast.args[0]).span.start)) {\n        // We are in a position a pipe name is expected.\n        const pipes = query.getPipes();\n        if (pipes) {\n          symbol = pipes.get(ast.name);\n          span = ast.span;\n        }\n      }\n    },\n    visitPrefixNot(ast) {},\n    visitNonNullAssert(ast) {},\n    visitPropertyRead(ast) {\n      const receiverType = getType(ast.receiver);\n      symbol = receiverType && receiverType.members().get(ast.name);\n      span = ast.span;\n    },\n    visitPropertyWrite(ast) {\n      const receiverType = getType(ast.receiver);\n      symbol = receiverType && receiverType.members().get(ast.name);\n      span = ast.span;\n    },\n    visitQuote(ast) {},\n    visitSafeMethodCall(ast) {\n      const receiverType = getType(ast.receiver);\n      symbol = receiverType && receiverType.members().get(ast.name);\n      span = ast.span;\n    },\n    visitSafePropertyRead(ast) {\n      const receiverType = getType(ast.receiver);\n      symbol = receiverType && receiverType.members().get(ast.name);\n      span = ast.span;\n    },\n  });\n\n  if (symbol && span) {\n    return {symbol, span};\n  }\n}\n"]}