{"version":3,"file":"typescript_host.js","sourceRoot":"","sources":["../../../../modules/@angular/language-service/src/typescript_host.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AotSummaryResolver, CompileDirectiveMetadata, CompilerConfig, StaticReflector, StaticSymbol, StaticSymbolCache, StaticSymbolResolver, componentModuleUrl, createOfflineCompileUrlResolver} from '@angular/compiler';\nimport {NgAnalyzedModules, analyzeNgModules, extractProgramSymbols} from '@angular/compiler/src/aot/compiler';\nimport {DirectiveNormalizer} from '@angular/compiler/src/directive_normalizer';\nimport {DirectiveResolver} from '@angular/compiler/src/directive_resolver';\nimport {CompileMetadataResolver} from '@angular/compiler/src/metadata_resolver';\nimport {HtmlParser} from '@angular/compiler/src/ml_parser/html_parser';\nimport {DEFAULT_INTERPOLATION_CONFIG, InterpolationConfig} from '@angular/compiler/src/ml_parser/interpolation_config';\nimport {ParseTreeResult, Parser} from '@angular/compiler/src/ml_parser/parser';\nimport {NgModuleResolver} from '@angular/compiler/src/ng_module_resolver';\nimport {PipeResolver} from '@angular/compiler/src/pipe_resolver';\nimport {ResourceLoader} from '@angular/compiler/src/resource_loader';\nimport {DomElementSchemaRegistry} from '@angular/compiler/src/schema/dom_element_schema_registry';\nimport {SummaryResolver} from '@angular/compiler/src/summary_resolver';\nimport {UrlResolver} from '@angular/compiler/src/url_resolver';\nimport {Type, ViewEncapsulation} from '@angular/core';\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport * as ts from 'typescript';\n\nimport {createLanguageService} from './language_service';\nimport {ReflectorHost} from './reflector_host';\nimport {BuiltinType, CompletionKind, Declaration, DeclarationError, Declarations, Definition, LanguageService, LanguageServiceHost, PipeInfo, Pipes, Signature, Span, Symbol, SymbolDeclaration, SymbolQuery, SymbolTable, TemplateSource, TemplateSources} from './types';\n\n// In TypeScript 2.1 these flags moved\n// These helpers work for both 2.0 and 2.1.\nconst isPrivate = (ts as any).ModifierFlags ?\n    ((node: ts.Node) =>\n         !!((ts as any).getCombinedModifierFlags(node) & (ts as any).ModifierFlags.Private)) :\n    ((node: ts.Node) => !!(node.flags & (ts as any).NodeFlags.Private));\nconst isReferenceType = (ts as any).ObjectFlags ?\n    ((type: ts.Type) =>\n         !!(type.flags & (ts as any).TypeFlags.Object &&\n            (type as any).objectFlags & (ts as any).ObjectFlags.Reference)) :\n    ((type: ts.Type) => !!(type.flags & (ts as any).TypeFlags.Reference));\n\n/**\n * Create a `LanguageServiceHost`\n */\nexport function createLanguageServiceFromTypescript(\n    host: ts.LanguageServiceHost, service: ts.LanguageService): LanguageService {\n  const ngHost = new TypeScriptServiceHost(host, service);\n  const ngServer = createLanguageService(ngHost);\n  ngHost.setSite(ngServer);\n  return ngServer;\n}\n\n/**\n * The language service never needs the normalized versions of the metadata. To avoid parsing\n * the content and resolving references, return an empty file. This also allows normalizing\n * template that are syntatically incorrect which is required to provide completions in\n * syntatically incorrect templates.\n */\nexport class DummyHtmlParser extends HtmlParser {\n  constructor() { super(); }\n\n  parse(\n      source: string, url: string, parseExpansionForms: boolean = false,\n      interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG): ParseTreeResult {\n    return new ParseTreeResult([], []);\n  }\n}\n\n/**\n * Avoid loading resources in the language servcie by using a dummy loader.\n */\nexport class DummyResourceLoader extends ResourceLoader {\n  get(url: string): Promise<string> { return Promise.resolve(''); }\n}\n\n/**\n * An implemntation of a `LanguageSerivceHost` for a TypeScript project.\n *\n * The `TypeScriptServiceHost` implements the Angular `LanguageServiceHost` using\n * the TypeScript language services.\n *\n * @expermental\n */\nexport class TypeScriptServiceHost implements LanguageServiceHost {\n  private _resolver: CompileMetadataResolver;\n  private _staticSymbolCache = new StaticSymbolCache();\n  private _staticSymbolResolver: StaticSymbolResolver;\n  private _reflector: StaticReflector;\n  private _reflectorHost: ReflectorHost;\n  private _checker: ts.TypeChecker;\n  private _typeCache: Symbol[] = [];\n  private context: string|undefined;\n  private lastProgram: ts.Program|undefined;\n  private modulesOutOfDate: boolean = true;\n  private analyzedModules: NgAnalyzedModules;\n  private service: LanguageService;\n  private fileToComponent: Map<string, StaticSymbol>;\n  private templateReferences: string[];\n  private collectedErrors: Map<string, any[]>;\n\n  constructor(private host: ts.LanguageServiceHost, private tsService: ts.LanguageService) {}\n\n  setSite(service: LanguageService) { this.service = service; }\n\n  /**\n   * Angular LanguageServiceHost implementation\n   */\n  get resolver(): CompileMetadataResolver {\n    this.validate();\n    let result = this._resolver;\n    if (!result) {\n      const moduleResolver = new NgModuleResolver(this.reflector);\n      const directiveResolver = new DirectiveResolver(this.reflector);\n      const pipeResolver = new PipeResolver(this.reflector);\n      const elementSchemaRegistry = new DomElementSchemaRegistry();\n      const resourceLoader = new DummyResourceLoader();\n      const urlResolver = createOfflineCompileUrlResolver();\n      const htmlParser = new DummyHtmlParser();\n      // This tracks the CompileConfig in codegen.ts. Currently these options\n      // are hard-coded except for genDebugInfo which is not applicable as we\n      // never generate code.\n      const config = new CompilerConfig({\n        genDebugInfo: false,\n        defaultEncapsulation: ViewEncapsulation.Emulated,\n        logBindingUpdate: false,\n        useJit: false\n      });\n      const directiveNormalizer =\n          new DirectiveNormalizer(resourceLoader, urlResolver, htmlParser, config);\n\n      result = this._resolver = new CompileMetadataResolver(\n          moduleResolver, directiveResolver, pipeResolver, new SummaryResolver(),\n          elementSchemaRegistry, directiveNormalizer, this._staticSymbolCache, this.reflector,\n          (error, type) => this.collectError(error, type && type.filePath));\n    }\n    return result;\n  }\n\n  getTemplateReferences(): string[] {\n    this.ensureTemplateMap();\n    return this.templateReferences;\n  }\n\n  getTemplateAt(fileName: string, position: number): TemplateSource|undefined {\n    let sourceFile = this.getSourceFile(fileName);\n    if (sourceFile) {\n      this.context = sourceFile.fileName;\n      let node = this.findNode(sourceFile, position);\n      if (node) {\n        return this.getSourceFromNode(\n            fileName, this.host.getScriptVersion(sourceFile.fileName), node);\n      }\n    } else {\n      this.ensureTemplateMap();\n      // TODO: Cannocalize the file?\n      const componentType = this.fileToComponent.get(fileName);\n      if (componentType) {\n        return this.getSourceFromType(\n            fileName, this.host.getScriptVersion(fileName), componentType);\n      }\n    }\n  }\n\n  getAnalyzedModules(): NgAnalyzedModules {\n    this.validate();\n    return this.ensureAnalyzedModules();\n  }\n\n  private ensureAnalyzedModules(): NgAnalyzedModules {\n    let analyzedModules = this.analyzedModules;\n    if (!analyzedModules) {\n      const analyzeHost = {isSourceFile(filePath: string) { return true; }};\n      const programSymbols = extractProgramSymbols(\n          this.staticSymbolResolver, this.program.getSourceFiles().map(sf => sf.fileName),\n          analyzeHost);\n\n      analyzedModules = this.analyzedModules =\n          analyzeNgModules(programSymbols, analyzeHost, this.resolver);\n    }\n    return analyzedModules;\n  }\n\n  getTemplates(fileName: string): TemplateSources {\n    this.ensureTemplateMap();\n    const componentType = this.fileToComponent.get(fileName);\n    if (componentType) {\n      const templateSource = this.getTemplateAt(fileName, 0);\n      if (templateSource) {\n        return [templateSource];\n      }\n    } else {\n      let version = this.host.getScriptVersion(fileName);\n      let result: TemplateSource[] = [];\n\n      // Find each template string in the file\n      let visit = (child: ts.Node) => {\n        let templateSource = this.getSourceFromNode(fileName, version, child);\n        if (templateSource) {\n          result.push(templateSource);\n        } else {\n          ts.forEachChild(child, visit);\n        }\n      };\n\n      let sourceFile = this.getSourceFile(fileName);\n      if (sourceFile) {\n        this.context = sourceFile.path;\n        ts.forEachChild(sourceFile, visit);\n      }\n      return result.length ? result : undefined;\n    }\n  }\n\n  getDeclarations(fileName: string): Declarations {\n    const result: Declarations = [];\n    const sourceFile = this.getSourceFile(fileName);\n    if (sourceFile) {\n      let visit = (child: ts.Node) => {\n        let declaration = this.getDeclarationFromNode(sourceFile, child);\n        if (declaration) {\n          result.push(declaration);\n        } else {\n          ts.forEachChild(child, visit);\n        }\n      };\n      ts.forEachChild(sourceFile, visit);\n    }\n    return result;\n  }\n\n  getSourceFile(fileName: string): ts.SourceFile {\n    return this.tsService.getProgram().getSourceFile(fileName);\n  }\n\n  updateAnalyzedModules() {\n    this.validate();\n    if (this.modulesOutOfDate) {\n      this.analyzedModules = null;\n      this._reflector = null;\n      this._staticSymbolResolver = null;\n      this.templateReferences = null;\n      this.fileToComponent = null;\n      this.ensureAnalyzedModules();\n      this.modulesOutOfDate = false;\n    }\n  }\n\n  private get program() { return this.tsService.getProgram(); }\n\n  private get checker() {\n    let checker = this._checker;\n    if (!checker) {\n      checker = this._checker = this.program.getTypeChecker();\n    }\n    return checker;\n  }\n\n  private validate() {\n    const program = this.program;\n    if (this.lastProgram != program) {\n      this.clearCaches();\n      this.lastProgram = program;\n    }\n  }\n\n  private clearCaches() {\n    this._checker = null;\n    this._typeCache = [];\n    this._resolver = null;\n    this.collectedErrors = null;\n    this.modulesOutOfDate = true;\n  }\n\n  private ensureTemplateMap() {\n    if (!this.fileToComponent || !this.templateReferences) {\n      const fileToComponent = new Map<string, StaticSymbol>();\n      const templateReference: string[] = [];\n      const ngModuleSummary = this.getAnalyzedModules();\n      const urlResolver = createOfflineCompileUrlResolver();\n      for (const module of ngModuleSummary.ngModules) {\n        for (const directive of module.declaredDirectives) {\n          const {metadata, annotation} =\n              this.resolver.getNonNormalizedDirectiveMetadata(directive.reference);\n          if (metadata.isComponent && metadata.template && metadata.template.templateUrl) {\n            const templateName = urlResolver.resolve(\n                componentModuleUrl(this.reflector, directive.reference, annotation),\n                metadata.template.templateUrl);\n            fileToComponent.set(templateName, directive.reference);\n            templateReference.push(templateName);\n          }\n        }\n      }\n      this.fileToComponent = fileToComponent;\n      this.templateReferences = templateReference;\n    }\n  }\n\n  private getSourceFromDeclaration(\n      fileName: string, version: string, source: string, span: Span, type: StaticSymbol,\n      declaration: ts.ClassDeclaration, node: ts.Node, sourceFile: ts.SourceFile): TemplateSource\n      |undefined {\n    let queryCache: SymbolQuery|undefined = undefined;\n    const t = this;\n    if (declaration) {\n      return {\n        version,\n        source,\n        span,\n        type,\n        get members():\n            SymbolTable{const checker = t.checker; const program = t.program;\n                        const type = checker.getTypeAtLocation(declaration);\n                        return new TypeWrapper(type, {node, program, checker}).members();},\n        get query(): SymbolQuery{\n          if (!queryCache) {\n            queryCache = new TypeScriptSymbolQuery(t.program, t.checker, sourceFile, () => {\n              const pipes = t.service.getPipesAt(fileName, node.getStart());\n              const checker = t.checker;\n              const program = t.program;\n              return new PipesTable(pipes, {node, program, checker});\n            });\n          } return queryCache;\n        }\n      };\n    }\n  }\n\n  private getSourceFromNode(fileName: string, version: string, node: ts.Node): TemplateSource\n      |undefined {\n    let result: TemplateSource|undefined = undefined;\n    const t = this;\n    switch (node.kind) {\n      case ts.SyntaxKind.NoSubstitutionTemplateLiteral:\n      case ts.SyntaxKind.StringLiteral:\n        let [declaration, decorator] = this.getTemplateClassDeclFromNode(node);\n        let queryCache: SymbolQuery|undefined = undefined;\n        if (declaration && declaration.name) {\n          const sourceFile = this.getSourceFile(fileName);\n          return this.getSourceFromDeclaration(\n              fileName, version, this.stringOf(node), shrink(spanOf(node)),\n              this.reflector.getStaticSymbol(sourceFile.fileName, declaration.name.text),\n              declaration, node, sourceFile);\n        }\n        break;\n    }\n    return result;\n  }\n\n  private getSourceFromType(fileName: string, version: string, type: StaticSymbol): TemplateSource\n      |undefined {\n    let result: TemplateSource|undefined = undefined;\n    const declaration = this.getTemplateClassFromStaticSymbol(type);\n    if (declaration) {\n      const snapshot = this.host.getScriptSnapshot(fileName);\n      const source = snapshot.getText(0, snapshot.getLength());\n      result = this.getSourceFromDeclaration(\n          fileName, version, source, {start: 0, end: source.length}, type, declaration, declaration,\n          declaration.getSourceFile());\n    }\n    return result;\n  }\n\n  private get reflectorHost(): ReflectorHost {\n    let result = this._reflectorHost;\n    if (!result) {\n      if (!this.context) {\n        // Make up a context by finding the first script and using that as the base dir.\n        this.context = this.host.getScriptFileNames()[0];\n      }\n\n      // Use the file context's directory as the base directory.\n      // The host's getCurrentDirectory() is not reliable as it is always \"\" in\n      // tsserver. We don't need the exact base directory, just one that contains\n      // a source file.\n      const source = this.tsService.getProgram().getSourceFile(this.context);\n      if (!source) {\n        throw new Error('Internal error: no context could be determined');\n      }\n\n      const tsConfigPath = findTsConfig(source.fileName);\n      const basePath = path.dirname(tsConfigPath || this.context);\n\n      result = this._reflectorHost = new ReflectorHost(\n          () => this.tsService.getProgram(), this.host, {basePath, genDir: basePath});\n    }\n    return result;\n  }\n\n  private collectError(error: any, filePath: string) {\n    let errorMap = this.collectedErrors;\n    if (!errorMap) {\n      errorMap = this.collectedErrors = new Map();\n    }\n    let errors = errorMap.get(filePath);\n    if (!errors) {\n      errors = [];\n      this.collectedErrors.set(filePath, errors);\n    }\n    errors.push(error);\n  }\n\n  private get staticSymbolResolver(): StaticSymbolResolver {\n    let result = this._staticSymbolResolver;\n    if (!result) {\n      const summaryResolver = new AotSummaryResolver(\n          {\n            loadSummary(filePath: string) { return null; },\n            isSourceFile(sourceFilePath: string) { return true; },\n            getOutputFileName(sourceFilePath: string) { return null; }\n          },\n          this._staticSymbolCache);\n      result = this._staticSymbolResolver = new StaticSymbolResolver(\n          this.reflectorHost, this._staticSymbolCache, summaryResolver,\n          (e, filePath) => this.collectError(e, filePath));\n    }\n    return result;\n  }\n\n  private get reflector(): StaticReflector {\n    let result = this._reflector;\n    if (!result) {\n      result = this._reflector = new StaticReflector(\n          this.staticSymbolResolver, [], [], (e, filePath) => this.collectError(e, filePath));\n    }\n    return result;\n  }\n\n  private getTemplateClassFromStaticSymbol(type: StaticSymbol): ts.ClassDeclaration|undefined {\n    const source = this.getSourceFile(type.filePath);\n    if (source) {\n      const declarationNode = ts.forEachChild(source, child => {\n        if (child.kind === ts.SyntaxKind.ClassDeclaration) {\n          const classDeclaration = child as ts.ClassDeclaration;\n          if (classDeclaration.name.text === type.name) {\n            return classDeclaration;\n          }\n        }\n      });\n      return declarationNode as ts.ClassDeclaration;\n    }\n\n    return undefined;\n  }\n\n  private static missingTemplate = <[ts.ClassDeclaration, ts.Expression]>[];\n\n  /**\n   * Given a template string node, see if it is an Angular template string, and if so return the\n   * containing class.\n   */\n  private getTemplateClassDeclFromNode(currentToken: ts.Node):\n      [ts.ClassDeclaration, ts.Expression] {\n    // Verify we are in a 'template' property assignment, in an object literal, which is an call\n    // arg, in a decorator\n    let parentNode = currentToken.parent;  // PropertyAssignment\n    if (!parentNode) {\n      return TypeScriptServiceHost.missingTemplate;\n    }\n    if (parentNode.kind !== ts.SyntaxKind.PropertyAssignment) {\n      return TypeScriptServiceHost.missingTemplate;\n    } else {\n      // TODO: Is this different for a literal, i.e. a quoted property name like \"template\"?\n      if ((parentNode as any).name.text !== 'template') {\n        return TypeScriptServiceHost.missingTemplate;\n      }\n    }\n    parentNode = parentNode.parent;  // ObjectLiteralExpression\n    if (!parentNode || parentNode.kind !== ts.SyntaxKind.ObjectLiteralExpression) {\n      return TypeScriptServiceHost.missingTemplate;\n    }\n\n    parentNode = parentNode.parent;  // CallExpression\n    if (!parentNode || parentNode.kind !== ts.SyntaxKind.CallExpression) {\n      return TypeScriptServiceHost.missingTemplate;\n    }\n    const callTarget = (<ts.CallExpression>parentNode).expression;\n\n    let decorator = parentNode.parent;  // Decorator\n    if (!decorator || decorator.kind !== ts.SyntaxKind.Decorator) {\n      return TypeScriptServiceHost.missingTemplate;\n    }\n\n    let declaration = <ts.ClassDeclaration>decorator.parent;  // ClassDeclaration\n    if (!declaration || declaration.kind !== ts.SyntaxKind.ClassDeclaration) {\n      return TypeScriptServiceHost.missingTemplate;\n    }\n    return [declaration, callTarget];\n  }\n\n  private getCollectedErrors(defaultSpan: Span, sourceFile: ts.SourceFile): DeclarationError[] {\n    const errors = (this.collectedErrors && this.collectedErrors.get(sourceFile.fileName));\n    return (errors && errors.map((e: any) => {\n             return {message: e.message, span: spanAt(sourceFile, e.line, e.column) || defaultSpan};\n           })) ||\n        [];\n  }\n\n  private getDeclarationFromNode(sourceFile: ts.SourceFile, node: ts.Node): Declaration|undefined {\n    if (node.kind == ts.SyntaxKind.ClassDeclaration && node.decorators &&\n        (node as ts.ClassDeclaration).name) {\n      for (const decorator of node.decorators) {\n        if (decorator.expression && decorator.expression.kind == ts.SyntaxKind.CallExpression) {\n          const classDeclaration = node as ts.ClassDeclaration;\n          if (classDeclaration.name) {\n            const call = decorator.expression as ts.CallExpression;\n            const target = call.expression;\n            const type = this.checker.getTypeAtLocation(target);\n            if (type) {\n              const staticSymbol =\n                  this._reflector.getStaticSymbol(sourceFile.fileName, classDeclaration.name.text);\n              try {\n                if (this.resolver.isDirective(staticSymbol as any)) {\n                  const {metadata} =\n                      this.resolver.getNonNormalizedDirectiveMetadata(staticSymbol as any);\n                  const declarationSpan = spanOf(target);\n                  return {\n                    type: staticSymbol,\n                    declarationSpan,\n                    metadata,\n                    errors: this.getCollectedErrors(declarationSpan, sourceFile)\n                  };\n                }\n              } catch (e) {\n                if (e.message) {\n                  this.collectError(e, sourceFile.fileName);\n                  const declarationSpan = spanOf(target);\n                  return {\n                    type: staticSymbol,\n                    declarationSpan,\n                    errors: this.getCollectedErrors(declarationSpan, sourceFile)\n                  };\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  private stringOf(node: ts.Node): string|undefined {\n    switch (node.kind) {\n      case ts.SyntaxKind.NoSubstitutionTemplateLiteral:\n        return (<ts.LiteralExpression>node).text;\n      case ts.SyntaxKind.StringLiteral:\n        return (<ts.StringLiteral>node).text;\n    }\n  }\n\n  private findNode(sourceFile: ts.SourceFile, position: number): ts.Node|undefined {\n    let _this = this;\n\n    function find(node: ts.Node): ts.Node|undefined {\n      if (position >= node.getStart() && position < node.getEnd()) {\n        return ts.forEachChild(node, find) || node;\n      }\n    }\n\n    return find(sourceFile);\n  }\n\n  private findLiteralType(kind: BuiltinType, context: TypeContext): Symbol {\n    const checker = this.checker;\n    let type: ts.Type;\n    switch (kind) {\n      case BuiltinType.Any:\n        type = checker.getTypeAtLocation(<ts.Node><any>{\n          kind: ts.SyntaxKind.AsExpression,\n          expression: <ts.Node>{kind: ts.SyntaxKind.TrueKeyword},\n          type: <ts.Node>{kind: ts.SyntaxKind.AnyKeyword}\n        });\n        break;\n      case BuiltinType.Boolean:\n        type = checker.getTypeAtLocation(<ts.Node>{kind: ts.SyntaxKind.TrueKeyword});\n        break;\n      case BuiltinType.Null:\n        type = checker.getTypeAtLocation(<ts.Node>{kind: ts.SyntaxKind.NullKeyword});\n        break;\n      case BuiltinType.Number:\n        type = checker.getTypeAtLocation(<ts.Node>{kind: ts.SyntaxKind.NumericLiteral});\n        break;\n      case BuiltinType.String:\n        type =\n            checker.getTypeAtLocation(<ts.Node>{kind: ts.SyntaxKind.NoSubstitutionTemplateLiteral});\n        break;\n      case BuiltinType.Undefined:\n        type = checker.getTypeAtLocation(<ts.Node>{kind: ts.SyntaxKind.VoidExpression});\n        break;\n      default:\n        throw new Error(`Internal error, unhandled literal kind ${kind}:${BuiltinType[kind]}`);\n    }\n    return new TypeWrapper(type, context);\n  }\n}\n\nclass TypeScriptSymbolQuery implements SymbolQuery {\n  private typeCache = new Map<BuiltinType, Symbol>();\n  private pipesCache: SymbolTable;\n\n  constructor(\n      private program: ts.Program, private checker: ts.TypeChecker, private source: ts.SourceFile,\n      private fetchPipes: () => SymbolTable) {}\n\n  getTypeKind(symbol: Symbol): BuiltinType { return typeKindOf(this.getTsTypeOf(symbol)); }\n\n  getBuiltinType(kind: BuiltinType): Symbol {\n    // TODO: Replace with typeChecker API when available.\n    let result = this.typeCache.get(kind);\n    if (!result) {\n      const type = getBuiltinTypeFromTs(\n          kind, {checker: this.checker, node: this.source, program: this.program});\n      result =\n          new TypeWrapper(type, {program: this.program, checker: this.checker, node: this.source});\n      this.typeCache.set(kind, result);\n    }\n    return result;\n  }\n\n  getTypeUnion(...types: Symbol[]): Symbol {\n    // TODO: Replace with typeChecker API when available\n    const checker = this.checker;\n\n    // No API exists so the cheat is to just return the last type any if no types are given.\n    return types.length ? types[types.length - 1] : this.getBuiltinType(BuiltinType.Any);\n  }\n\n  getArrayType(type: Symbol): Symbol {\n    // TODO: Replace with typeChecker API when available\n    return this.getBuiltinType(BuiltinType.Any);\n  }\n\n  getElementType(type: Symbol): Symbol {\n    if (type instanceof TypeWrapper) {\n      const elementType = getTypeParameterOf(type.tsType, 'Array');\n      if (elementType) {\n        return new TypeWrapper(elementType, type.context);\n      }\n    }\n  }\n\n  getNonNullableType(symbol: Symbol): Symbol {\n    // TODO: Replace with typeChecker API when available;\n    return symbol;\n  }\n\n  getPipes(): SymbolTable {\n    let result = this.pipesCache;\n    if (!result) {\n      result = this.pipesCache = this.fetchPipes();\n    }\n    return result;\n  }\n\n  getTemplateContext(type: StaticSymbol): SymbolTable {\n    const context: TypeContext = {node: this.source, program: this.program, checker: this.checker};\n    const typeSymbol = findClassSymbolInContext(type, context);\n    if (typeSymbol) {\n      const contextType = this.getTemplateRefContextType(typeSymbol);\n      if (contextType) return new SymbolWrapper(contextType, context).members();\n    }\n  }\n\n  getTypeSymbol(type: StaticSymbol): Symbol {\n    const context: TypeContext = {node: this.source, program: this.program, checker: this.checker};\n    const typeSymbol = findClassSymbolInContext(type, context);\n    return new SymbolWrapper(typeSymbol, context);\n  }\n\n  createSymbolTable(symbols: SymbolDeclaration[]): SymbolTable {\n    const result = new MapSymbolTable();\n    result.addAll(symbols.map(s => new DeclaredSymbol(s)));\n    return result;\n  }\n\n  mergeSymbolTable(symbolTables: SymbolTable[]): SymbolTable {\n    const result = new MapSymbolTable();\n    for (const symbolTable of symbolTables) {\n      result.addAll(symbolTable.values());\n    }\n    return result;\n  }\n\n  getSpanAt(line: number, column: number): Span { return spanAt(this.source, line, column); }\n\n  private getTemplateRefContextType(type: ts.Symbol): ts.Symbol {\n    const constructor = type.members['__constructor'];\n    if (constructor) {\n      const constructorDeclaration = constructor.declarations[0] as ts.ConstructorTypeNode;\n      for (const parameter of constructorDeclaration.parameters) {\n        const type = this.checker.getTypeAtLocation(parameter.type);\n        if (type.symbol.name == 'TemplateRef' && isReferenceType(type)) {\n          const typeReference = type as ts.TypeReference;\n          if (typeReference.typeArguments.length === 1) {\n            return typeReference.typeArguments[0].symbol;\n          }\n        }\n      };\n    }\n  }\n\n  private getTsTypeOf(symbol: Symbol): ts.Type {\n    const type = this.getTypeWrapper(symbol);\n    return type && type.tsType;\n  }\n\n  private getTypeWrapper(symbol: Symbol): TypeWrapper|undefined {\n    let type: TypeWrapper|undefined = undefined;\n    if (symbol instanceof TypeWrapper) {\n      type = symbol;\n    } else if (symbol.type instanceof TypeWrapper) {\n      type = symbol.type;\n    }\n    return type;\n  }\n}\n\ninterface TypeContext {\n  node: ts.Node;\n  program: ts.Program;\n  checker: ts.TypeChecker;\n}\n\nfunction typeCallable(type: ts.Type): boolean {\n  const signatures = type.getCallSignatures();\n  return signatures && signatures.length != 0;\n}\n\nfunction signaturesOf(type: ts.Type, context: TypeContext): Signature[] {\n  return type.getCallSignatures().map(s => new SignatureWrapper(s, context));\n}\n\nfunction selectSignature(type: ts.Type, context: TypeContext, types: Symbol[]): Signature|\n    undefined {\n  // TODO: Do a better job of selecting the right signature.\n  const signatures = type.getCallSignatures();\n  return signatures.length ? new SignatureWrapper(signatures[0], context) : undefined;\n}\n\nfunction toSymbolTable(symbols: ts.Symbol[]): ts.SymbolTable {\n  const result: ts.SymbolTable = <any>{};\n  for (const symbol of symbols) {\n    result[symbol.name] = symbol;\n  }\n  return result;\n}\n\nfunction toSymbols(symbolTable: ts.SymbolTable, filter?: (symbol: ts.Symbol) => boolean) {\n  const result: ts.Symbol[] = [];\n  const own = typeof symbolTable.hasOwnProperty === 'function' ?\n      (name: string) => symbolTable.hasOwnProperty(name) :\n      (name: string) => !!symbolTable[name];\n  for (const name in symbolTable) {\n    if (own(name) && (!filter || filter(symbolTable[name]))) {\n      result.push(symbolTable[name]);\n    }\n  }\n  return result;\n}\n\nclass TypeWrapper implements Symbol {\n  constructor(public tsType: ts.Type, public context: TypeContext) {\n    if (!tsType) {\n      throw Error('Internal: null type');\n    }\n  }\n\n  get name(): string {\n    const symbol = this.tsType.symbol;\n    return (symbol && symbol.name) || '<anonymous>';\n  }\n\n  get kind(): CompletionKind { return 'type'; }\n\n  get language(): string { return 'typescript'; }\n\n  get type(): Symbol|undefined { return undefined; }\n\n  get container(): Symbol|undefined { return undefined; }\n\n  get public(): boolean { return true; }\n\n  get callable(): boolean { return typeCallable(this.tsType); }\n\n  get definition(): Definition { return definitionFromTsSymbol(this.tsType.getSymbol()); }\n\n  members(): SymbolTable {\n    return new SymbolTableWrapper(this.tsType.getProperties(), this.context);\n  }\n\n  signatures(): Signature[] { return signaturesOf(this.tsType, this.context); }\n\n  selectSignature(types: Symbol[]): Signature|undefined {\n    return selectSignature(this.tsType, this.context, types);\n  }\n\n  indexed(argument: Symbol): Symbol|undefined { return undefined; }\n}\n\nclass SymbolWrapper implements Symbol {\n  private _tsType: ts.Type;\n\n  constructor(private symbol: ts.Symbol, private context: TypeContext) {}\n\n  get name(): string { return this.symbol.name; }\n\n  get kind(): CompletionKind { return this.callable ? 'method' : 'property'; }\n\n  get language(): string { return 'typescript'; }\n\n  get type(): Symbol|undefined { return new TypeWrapper(this.tsType, this.context); }\n\n  get container(): Symbol|undefined { return getContainerOf(this.symbol, this.context); }\n\n  get public(): boolean {\n    // Symbols that are not explicitly made private are public.\n    return !isSymbolPrivate(this.symbol);\n  }\n\n  get callable(): boolean { return typeCallable(this.tsType); }\n\n  get definition(): Definition { return definitionFromTsSymbol(this.symbol); }\n\n  members(): SymbolTable { return new SymbolTableWrapper(this.symbol.members, this.context); }\n\n  signatures(): Signature[] { return signaturesOf(this.tsType, this.context); }\n\n  selectSignature(types: Symbol[]): Signature|undefined {\n    return selectSignature(this.tsType, this.context, types);\n  }\n\n  indexed(argument: Symbol): Symbol|undefined { return undefined; }\n\n  private get tsType(): ts.Type {\n    let type = this._tsType;\n    if (!type) {\n      type = this._tsType =\n          this.context.checker.getTypeOfSymbolAtLocation(this.symbol, this.context.node);\n    }\n    return type;\n  }\n}\n\nclass DeclaredSymbol implements Symbol {\n  constructor(private declaration: SymbolDeclaration) {}\n\n  get name() { return this.declaration.name; }\n\n  get kind() { return this.declaration.kind; }\n\n  get language(): string { return 'ng-template'; }\n\n  get container(): Symbol|undefined { return undefined; }\n\n  get type() { return this.declaration.type; }\n\n  get callable(): boolean { return this.declaration.type.callable; }\n\n  get public(): boolean { return true; }\n\n  get definition(): Definition { return this.declaration.definition; }\n\n  members(): SymbolTable { return this.declaration.type.members(); }\n\n  signatures(): Signature[] { return this.declaration.type.signatures(); }\n\n  selectSignature(types: Symbol[]): Signature|undefined {\n    return this.declaration.type.selectSignature(types);\n  }\n\n  indexed(argument: Symbol): Symbol|undefined { return undefined; }\n}\n\nclass SignatureWrapper implements Signature {\n  constructor(private signature: ts.Signature, private context: TypeContext) {}\n\n  get arguments(): SymbolTable {\n    return new SymbolTableWrapper(this.signature.getParameters(), this.context);\n  }\n\n  get result(): Symbol { return new TypeWrapper(this.signature.getReturnType(), this.context); }\n}\n\nclass SignatureResultOverride implements Signature {\n  constructor(private signature: Signature, private resultType: Symbol) {}\n\n  get arguments(): SymbolTable { return this.signature.arguments; }\n\n  get result(): Symbol { return this.resultType; }\n}\n\nclass SymbolTableWrapper implements SymbolTable {\n  private symbols: ts.Symbol[];\n  private symbolTable: ts.SymbolTable;\n\n  constructor(\n      symbols: ts.SymbolTable|ts.Symbol[], private context: TypeContext,\n      filter?: (symbol: ts.Symbol) => boolean) {\n    if (Array.isArray(symbols)) {\n      this.symbols = filter ? symbols.filter(filter) : symbols;\n      this.symbolTable = toSymbolTable(symbols);\n    } else {\n      this.symbols = toSymbols(symbols, filter);\n      this.symbolTable = filter ? toSymbolTable(this.symbols) : symbols;\n    }\n  }\n\n  get size(): number { return this.symbols.length; }\n\n  get(key: string): Symbol|undefined {\n    const symbol = this.symbolTable[key];\n    return symbol ? new SymbolWrapper(symbol, this.context) : undefined;\n  }\n\n  has(key: string): boolean { return this.symbolTable[key] != null; }\n\n  values(): Symbol[] { return this.symbols.map(s => new SymbolWrapper(s, this.context)); }\n}\n\nclass MapSymbolTable implements SymbolTable {\n  private map = new Map<string, Symbol>();\n  private _values: Symbol[] = [];\n\n  get size(): number { return this.map.size; }\n\n  get(key: string): Symbol|undefined { return this.map.get(key); }\n\n  add(symbol: Symbol) {\n    if (this.map.has(symbol.name)) {\n      const previous = this.map.get(symbol.name);\n      this._values[this._values.indexOf(previous)] = symbol;\n    }\n    this.map.set(symbol.name, symbol);\n    this._values.push(symbol);\n  }\n\n  addAll(symbols: Symbol[]) {\n    for (const symbol of symbols) {\n      this.add(symbol);\n    }\n  }\n\n  has(key: string): boolean { return this.map.has(key); }\n\n  values(): Symbol[] {\n    // Switch to this.map.values once iterables are supported by the target language.\n    return this._values;\n  }\n}\n\nclass PipesTable implements SymbolTable {\n  constructor(private pipes: Pipes, private context: TypeContext) {}\n\n  get size() { return this.pipes.length; }\n\n  get(key: string): Symbol {\n    const pipe = this.pipes.find(pipe => pipe.name == key);\n    if (pipe) {\n      return new PipeSymbol(pipe, this.context);\n    }\n  }\n\n  has(key: string): boolean { return this.pipes.find(pipe => pipe.name == key) != null; }\n\n  values(): Symbol[] { return this.pipes.map(pipe => new PipeSymbol(pipe, this.context)); }\n}\n\nclass PipeSymbol implements Symbol {\n  private _tsType: ts.Type;\n\n  constructor(private pipe: PipeInfo, private context: TypeContext) {}\n\n  get name(): string { return this.pipe.name; }\n\n  get kind(): CompletionKind { return 'pipe'; }\n\n  get language(): string { return 'typescript'; }\n\n  get type(): Symbol|undefined { return new TypeWrapper(this.tsType, this.context); }\n\n  get container(): Symbol|undefined { return undefined; }\n\n  get callable(): boolean { return true; }\n\n  get public(): boolean { return true; }\n\n  get definition(): Definition { return definitionFromTsSymbol(this.tsType.getSymbol()); }\n\n  members(): SymbolTable { return EmptyTable.instance; }\n\n  signatures(): Signature[] { return signaturesOf(this.tsType, this.context); }\n\n  selectSignature(types: Symbol[]): Signature|undefined {\n    let signature = selectSignature(this.tsType, this.context, types);\n    if (types.length == 1) {\n      const parameterType = types[0];\n      if (parameterType instanceof TypeWrapper) {\n        let resultType: ts.Type = undefined;\n        switch (this.name) {\n          case 'async':\n            switch (parameterType.name) {\n              case 'Observable':\n              case 'Promise':\n              case 'EventEmitter':\n                resultType = getTypeParameterOf(parameterType.tsType, parameterType.name);\n                break;\n            }\n            break;\n          case 'slice':\n            resultType = getTypeParameterOf(parameterType.tsType, 'Array');\n            break;\n        }\n        if (resultType) {\n          signature = new SignatureResultOverride(\n              signature, new TypeWrapper(resultType, parameterType.context));\n        }\n      }\n    }\n    return signature;\n  }\n\n  indexed(argument: Symbol): Symbol|undefined { return undefined; }\n\n  private get tsType(): ts.Type {\n    let type = this._tsType;\n    if (!type) {\n      const classSymbol = this.findClassSymbol(this.pipe.symbol);\n      if (classSymbol) {\n        type = this._tsType = this.findTransformMethodType(classSymbol);\n      }\n      if (!type) {\n        type = this._tsType = getBuiltinTypeFromTs(BuiltinType.Any, this.context);\n      }\n    }\n    return type;\n  }\n\n  private findClassSymbol(type: StaticSymbol): ts.Symbol {\n    return findClassSymbolInContext(type, this.context);\n  }\n\n  private findTransformMethodType(classSymbol: ts.Symbol): ts.Type {\n    const transform = classSymbol.members['transform'];\n    if (transform) {\n      return this.context.checker.getTypeOfSymbolAtLocation(transform, this.context.node);\n    }\n  }\n}\n\nfunction findClassSymbolInContext(type: StaticSymbol, context: TypeContext): ts.Symbol {\n  const sourceFile = context.program.getSourceFile(type.filePath);\n  if (sourceFile) {\n    const moduleSymbol = (sourceFile as any).module || (sourceFile as any).symbol;\n    const exports = context.checker.getExportsOfModule(moduleSymbol);\n    return (exports || []).find(symbol => symbol.name == type.name);\n  }\n}\n\nclass EmptyTable implements SymbolTable {\n  get size(): number { return 0; }\n  get(key: string): Symbol|undefined { return undefined; }\n  has(key: string): boolean { return false; }\n  values(): Symbol[] { return []; }\n  static instance = new EmptyTable();\n}\n\nfunction findTsConfig(fileName: string): string {\n  let dir = path.dirname(fileName);\n  while (fs.existsSync(dir)) {\n    const candidate = path.join(dir, 'tsconfig.json');\n    if (fs.existsSync(candidate)) return candidate;\n    dir = path.dirname(dir);\n  }\n}\n\nfunction isBindingPattern(node: ts.Node): node is ts.BindingPattern {\n  return !!node && (node.kind === ts.SyntaxKind.ArrayBindingPattern ||\n                    node.kind === ts.SyntaxKind.ObjectBindingPattern);\n}\n\nfunction walkUpBindingElementsAndPatterns(node: ts.Node): ts.Node {\n  while (node && (node.kind === ts.SyntaxKind.BindingElement || isBindingPattern(node))) {\n    node = node.parent;\n  }\n\n  return node;\n}\n\nfunction getCombinedNodeFlags(node: ts.Node): ts.NodeFlags {\n  node = walkUpBindingElementsAndPatterns(node);\n\n  let flags = node.flags;\n  if (node.kind === ts.SyntaxKind.VariableDeclaration) {\n    node = node.parent;\n  }\n\n  if (node && node.kind === ts.SyntaxKind.VariableDeclarationList) {\n    flags |= node.flags;\n    node = node.parent;\n  }\n\n  if (node && node.kind === ts.SyntaxKind.VariableStatement) {\n    flags |= node.flags;\n  }\n\n  return flags;\n}\n\nfunction isSymbolPrivate(s: ts.Symbol): boolean {\n  return s.valueDeclaration && isPrivate(s.valueDeclaration);\n}\n\nfunction getBuiltinTypeFromTs(kind: BuiltinType, context: TypeContext): ts.Type {\n  let type: ts.Type;\n  const checker = context.checker;\n  const node = context.node;\n  switch (kind) {\n    case BuiltinType.Any:\n      type = checker.getTypeAtLocation(setParents(\n          <ts.Node><any>{\n            kind: ts.SyntaxKind.AsExpression,\n            expression: <ts.Node>{kind: ts.SyntaxKind.TrueKeyword},\n            type: <ts.Node>{kind: ts.SyntaxKind.AnyKeyword}\n          },\n          node));\n      break;\n    case BuiltinType.Boolean:\n      type =\n          checker.getTypeAtLocation(setParents(<ts.Node>{kind: ts.SyntaxKind.TrueKeyword}, node));\n      break;\n    case BuiltinType.Null:\n      type =\n          checker.getTypeAtLocation(setParents(<ts.Node>{kind: ts.SyntaxKind.NullKeyword}, node));\n      break;\n    case BuiltinType.Number:\n      const numeric = <ts.Node>{kind: ts.SyntaxKind.NumericLiteral};\n      setParents(<any>{kind: ts.SyntaxKind.ExpressionStatement, expression: numeric}, node);\n      type = checker.getTypeAtLocation(numeric);\n      break;\n    case BuiltinType.String:\n      type = checker.getTypeAtLocation(\n          setParents(<ts.Node>{kind: ts.SyntaxKind.NoSubstitutionTemplateLiteral}, node));\n      break;\n    case BuiltinType.Undefined:\n      type = checker.getTypeAtLocation(setParents(\n          <ts.Node><any>{\n            kind: ts.SyntaxKind.VoidExpression,\n            expression: <ts.Node>{kind: ts.SyntaxKind.NumericLiteral}\n          },\n          node));\n      break;\n    default:\n      throw new Error(`Internal error, unhandled literal kind ${kind}:${BuiltinType[kind]}`);\n  }\n  return type;\n}\n\nfunction setParents<T extends ts.Node>(node: T, parent: ts.Node): T {\n  node.parent = parent;\n  ts.forEachChild(node, child => setParents(child, node));\n  return node;\n}\n\nfunction spanOf(node: ts.Node): Span {\n  return {start: node.getStart(), end: node.getEnd()};\n}\n\nfunction shrink(span: Span, offset?: number) {\n  if (offset == null) offset = 1;\n  return {start: span.start + offset, end: span.end - offset};\n}\n\nfunction spanAt(sourceFile: ts.SourceFile, line: number, column: number): Span {\n  if (line != null && column != null) {\n    const position = ts.getPositionOfLineAndCharacter(sourceFile, line, column);\n    const findChild = function findChild(node: ts.Node): ts.Node {\n      if (node.kind > ts.SyntaxKind.LastToken && node.pos <= position && node.end > position) {\n        const betterNode = ts.forEachChild(node, findChild);\n        return betterNode || node;\n      }\n    };\n\n    const node = ts.forEachChild(sourceFile, findChild);\n    if (node) {\n      return {start: node.getStart(), end: node.getEnd()};\n    }\n  }\n}\n\nfunction definitionFromTsSymbol(symbol: ts.Symbol): Definition {\n  const declarations = symbol.declarations;\n  if (declarations) {\n    return declarations.map(declaration => {\n      const sourceFile = declaration.getSourceFile();\n      return {\n        fileName: sourceFile.fileName,\n        span: {start: declaration.getStart(), end: declaration.getEnd()}\n      };\n    });\n  }\n}\n\nfunction parentDeclarationOf(node: ts.Node): ts.Node {\n  while (node) {\n    switch (node.kind) {\n      case ts.SyntaxKind.ClassDeclaration:\n      case ts.SyntaxKind.InterfaceDeclaration:\n        return node;\n      case ts.SyntaxKind.SourceFile:\n        return null;\n    }\n    node = node.parent;\n  }\n}\n\nfunction getContainerOf(symbol: ts.Symbol, context: TypeContext): Symbol {\n  if (symbol.getFlags() & ts.SymbolFlags.ClassMember && symbol.declarations) {\n    for (const declaration of symbol.declarations) {\n      const parent = parentDeclarationOf(declaration);\n      if (parent) {\n        const type = context.checker.getTypeAtLocation(parent);\n        if (type) {\n          return new TypeWrapper(type, context);\n        }\n      }\n    }\n  }\n}\n\nfunction getTypeParameterOf(type: ts.Type, name: string): ts.Type {\n  if (type && type.symbol && type.symbol.name == name) {\n    const typeArguments: ts.Type[] = (type as any).typeArguments;\n    if (typeArguments && typeArguments.length <= 1) {\n      return typeArguments[0];\n    }\n  }\n}\n\nfunction typeKindOf(type: ts.Type): BuiltinType {\n  if (type) {\n    if (type.flags & ts.TypeFlags.Any) {\n      return BuiltinType.Any;\n    } else if (\n        type.flags & (ts.TypeFlags.String | ts.TypeFlags.StringLike | ts.TypeFlags.StringLiteral)) {\n      return BuiltinType.String;\n    } else if (type.flags & (ts.TypeFlags.Number | ts.TypeFlags.NumberLike)) {\n      return BuiltinType.Number;\n    } else if (type.flags & (ts.TypeFlags.Undefined)) {\n      return BuiltinType.Undefined;\n    } else if (type.flags & (ts.TypeFlags.Null)) {\n      return BuiltinType.Null;\n    } else if (type.flags & ts.TypeFlags.Union) {\n      // If all the constituent types of a union are the same kind, it is also that kind.\n      let candidate: BuiltinType;\n      const unionType = type as ts.UnionType;\n      if (unionType.types.length > 0) {\n        candidate = typeKindOf(unionType.types[0]);\n        for (const subType of unionType.types) {\n          if (candidate != typeKindOf(subType)) {\n            return BuiltinType.Other;\n          }\n        }\n      }\n      return candidate;\n    }\n  }\n  return BuiltinType.Other;\n}\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}