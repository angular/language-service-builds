{"version":3,"file":"expressions.js","sourceRoot":"","sources":["../../../../modules/@angular/language-service/src/expressions.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {StaticSymbol, identifierName, tokenReference} from '@angular/compiler';\nimport {AST, ASTWithSource, AstVisitor, Binary, BindingPipe, Chain, Conditional, FunctionCall, ImplicitReceiver, Interpolation, KeyedRead, KeyedWrite, LiteralArray, LiteralMap, LiteralPrimitive, MethodCall, PrefixNot, PropertyRead, PropertyWrite, Quote, SafeMethodCall, SafePropertyRead} from '@angular/compiler/src/expression_parser/ast';\nimport {ElementAst, EmbeddedTemplateAst, ReferenceAst, TemplateAst, templateVisitAll} from '@angular/compiler/src/template_parser/template_ast';\n\nimport {AstPath as AstPathBase} from './ast_path';\nimport {TemplateInfo} from './common';\nimport {TemplateAstChildVisitor, TemplateAstPath} from './template_path';\nimport {BuiltinType, CompletionKind, Definition, DiagnosticKind, Signature, Span, Symbol, SymbolDeclaration, SymbolQuery, SymbolTable} from './types';\nimport {inSpan, spanOf} from './utils';\n\nexport function getExpressionDiagnostics(\n    scope: SymbolTable, ast: AST, query: SymbolQuery): TypeDiagnostic[] {\n  const analyzer = new AstType(scope, query);\n  analyzer.getDiagnostics(ast);\n  return analyzer.diagnostics;\n}\n\nexport function getExpressionCompletions(\n    scope: SymbolTable, ast: AST, position: number, query: SymbolQuery): Symbol[] {\n  const path = new AstPath(ast, position);\n  if (path.empty) return undefined;\n  const tail = path.tail;\n  let result: SymbolTable|undefined = scope;\n\n  function getType(ast: AST): Symbol { return new AstType(scope, query).getType(ast); }\n\n  // If the completion request is in a not in a pipe or property access then the global scope\n  // (that is the scope of the implicit receiver) is the right scope as the user is typing the\n  // beginning of an expression.\n  tail.visit({\n    visitBinary(ast) {},\n    visitChain(ast) {},\n    visitConditional(ast) {},\n    visitFunctionCall(ast) {},\n    visitImplicitReceiver(ast) {},\n    visitInterpolation(ast) { result = undefined; },\n    visitKeyedRead(ast) {},\n    visitKeyedWrite(ast) {},\n    visitLiteralArray(ast) {},\n    visitLiteralMap(ast) {},\n    visitLiteralPrimitive(ast) {},\n    visitMethodCall(ast) {},\n    visitPipe(ast) {\n      if (position >= ast.exp.span.end &&\n          (!ast.args || !ast.args.length || position < (<AST>ast.args[0]).span.start)) {\n        // We are in a position a pipe name is expected.\n        result = query.getPipes();\n      }\n    },\n    visitPrefixNot(ast) {},\n    visitPropertyRead(ast) {\n      const receiverType = getType(ast.receiver);\n      result = receiverType ? receiverType.members() : scope;\n    },\n    visitPropertyWrite(ast) {\n      const receiverType = getType(ast.receiver);\n      result = receiverType ? receiverType.members() : scope;\n    },\n    visitQuote(ast) {\n      // For a quote, return the members of any (if there are any).\n      result = query.getBuiltinType(BuiltinType.Any).members();\n    },\n    visitSafeMethodCall(ast) {\n      const receiverType = getType(ast.receiver);\n      result = receiverType ? receiverType.members() : scope;\n    },\n    visitSafePropertyRead(ast) {\n      const receiverType = getType(ast.receiver);\n      result = receiverType ? receiverType.members() : scope;\n    },\n  });\n\n  return result && result.values();\n}\n\nexport function getExpressionSymbol(\n    scope: SymbolTable, ast: AST, position: number,\n    query: SymbolQuery): {symbol: Symbol, span: Span} {\n  const path = new AstPath(ast, position, /* excludeEmpty */ true);\n  if (path.empty) return undefined;\n  const tail = path.tail;\n\n  function getType(ast: AST): Symbol { return new AstType(scope, query).getType(ast); }\n\n  let symbol: Symbol = undefined;\n  let span: Span = undefined;\n\n  // If the completion request is in a not in a pipe or property access then the global scope\n  // (that is the scope of the implicit receiver) is the right scope as the user is typing the\n  // beginning of an expression.\n  tail.visit({\n    visitBinary(ast) {},\n    visitChain(ast) {},\n    visitConditional(ast) {},\n    visitFunctionCall(ast) {},\n    visitImplicitReceiver(ast) {},\n    visitInterpolation(ast) {},\n    visitKeyedRead(ast) {},\n    visitKeyedWrite(ast) {},\n    visitLiteralArray(ast) {},\n    visitLiteralMap(ast) {},\n    visitLiteralPrimitive(ast) {},\n    visitMethodCall(ast) {\n      const receiverType = getType(ast.receiver);\n      symbol = receiverType && receiverType.members().get(ast.name);\n      span = ast.span;\n    },\n    visitPipe(ast) {\n      if (position >= ast.exp.span.end &&\n          (!ast.args || !ast.args.length || position < (<AST>ast.args[0]).span.start)) {\n        // We are in a position a pipe name is expected.\n        const pipes = query.getPipes();\n        if (pipes) {\n          symbol = pipes.get(ast.name);\n          span = ast.span;\n        }\n      }\n    },\n    visitPrefixNot(ast) {},\n    visitPropertyRead(ast) {\n      const receiverType = getType(ast.receiver);\n      symbol = receiverType && receiverType.members().get(ast.name);\n      span = ast.span;\n    },\n    visitPropertyWrite(ast) {\n      const receiverType = getType(ast.receiver);\n      symbol = receiverType && receiverType.members().get(ast.name);\n      span = ast.span;\n    },\n    visitQuote(ast) {},\n    visitSafeMethodCall(ast) {\n      const receiverType = getType(ast.receiver);\n      symbol = receiverType && receiverType.members().get(ast.name);\n      span = ast.span;\n    },\n    visitSafePropertyRead(ast) {\n      const receiverType = getType(ast.receiver);\n      symbol = receiverType && receiverType.members().get(ast.name);\n      span = ast.span;\n    },\n  });\n\n  if (symbol && span) {\n    return {symbol, span};\n  }\n}\n\ninterface ExpressionVisitor extends AstVisitor {\n  visit?(ast: AST, context?: any): any;\n}\n\n\n// Consider moving to expression_parser/ast\nclass NullVisitor implements ExpressionVisitor {\n  visitBinary(ast: Binary): void {}\n  visitChain(ast: Chain): void {}\n  visitConditional(ast: Conditional): void {}\n  visitFunctionCall(ast: FunctionCall): void {}\n  visitImplicitReceiver(ast: ImplicitReceiver): void {}\n  visitInterpolation(ast: Interpolation): void {}\n  visitKeyedRead(ast: KeyedRead): void {}\n  visitKeyedWrite(ast: KeyedWrite): void {}\n  visitLiteralArray(ast: LiteralArray): void {}\n  visitLiteralMap(ast: LiteralMap): void {}\n  visitLiteralPrimitive(ast: LiteralPrimitive): void {}\n  visitMethodCall(ast: MethodCall): void {}\n  visitPipe(ast: BindingPipe): void {}\n  visitPrefixNot(ast: PrefixNot): void {}\n  visitPropertyRead(ast: PropertyRead): void {}\n  visitPropertyWrite(ast: PropertyWrite): void {}\n  visitQuote(ast: Quote): void {}\n  visitSafeMethodCall(ast: SafeMethodCall): void {}\n  visitSafePropertyRead(ast: SafePropertyRead): void {}\n}\n\nexport class TypeDiagnostic {\n  constructor(public kind: DiagnosticKind, public message: string, public ast: AST) {}\n}\n\n// AstType calculatetype of the ast given AST element.\nclass AstType implements ExpressionVisitor {\n  public diagnostics: TypeDiagnostic[];\n\n  constructor(private scope: SymbolTable, private query: SymbolQuery) {}\n\n  getType(ast: AST): Symbol { return ast.visit(this); }\n\n  getDiagnostics(ast: AST): TypeDiagnostic[] {\n    this.diagnostics = [];\n    ast.visit(this);\n    return this.diagnostics;\n  }\n\n  visitBinary(ast: Binary): Symbol {\n    // Treat undefined and null as other.\n    function normalize(kind: BuiltinType): BuiltinType {\n      switch (kind) {\n        case BuiltinType.Undefined:\n        case BuiltinType.Null:\n          return BuiltinType.Other;\n      }\n      return kind;\n    }\n\n    const leftType = this.getType(ast.left);\n    const rightType = this.getType(ast.right);\n    const leftKind = normalize(this.query.getTypeKind(leftType));\n    const rightKind = normalize(this.query.getTypeKind(rightType));\n\n    // The following swtich implements operator typing similar to the\n    // type production tables in the TypeScript specification.\n    const operKind = leftKind << 8 | rightKind;\n    switch (ast.operation) {\n      case '*':\n      case '/':\n      case '%':\n      case '-':\n      case '<<':\n      case '>>':\n      case '>>>':\n      case '&':\n      case '^':\n      case '|':\n        switch (operKind) {\n          case BuiltinType.Any << 8 | BuiltinType.Any:\n          case BuiltinType.Number << 8 | BuiltinType.Any:\n          case BuiltinType.Any << 8 | BuiltinType.Number:\n          case BuiltinType.Number << 8 | BuiltinType.Number:\n            return this.query.getBuiltinType(BuiltinType.Number);\n          default:\n            let errorAst = ast.left;\n            switch (leftKind) {\n              case BuiltinType.Any:\n              case BuiltinType.Number:\n                errorAst = ast.right;\n                break;\n            }\n            return this.reportError('Expected a numeric type', errorAst);\n        }\n      case '+':\n        switch (operKind) {\n          case BuiltinType.Any << 8 | BuiltinType.Any:\n          case BuiltinType.Any << 8 | BuiltinType.Boolean:\n          case BuiltinType.Any << 8 | BuiltinType.Number:\n          case BuiltinType.Any << 8 | BuiltinType.Other:\n          case BuiltinType.Boolean << 8 | BuiltinType.Any:\n          case BuiltinType.Number << 8 | BuiltinType.Any:\n          case BuiltinType.Other << 8 | BuiltinType.Any:\n            return this.anyType;\n          case BuiltinType.Any << 8 | BuiltinType.String:\n          case BuiltinType.Boolean << 8 | BuiltinType.String:\n          case BuiltinType.Number << 8 | BuiltinType.String:\n          case BuiltinType.String << 8 | BuiltinType.Any:\n          case BuiltinType.String << 8 | BuiltinType.Boolean:\n          case BuiltinType.String << 8 | BuiltinType.Number:\n          case BuiltinType.String << 8 | BuiltinType.String:\n          case BuiltinType.String << 8 | BuiltinType.Other:\n          case BuiltinType.Other << 8 | BuiltinType.String:\n            return this.query.getBuiltinType(BuiltinType.String);\n          case BuiltinType.Number << 8 | BuiltinType.Number:\n            return this.query.getBuiltinType(BuiltinType.Number);\n          case BuiltinType.Boolean << 8 | BuiltinType.Number:\n          case BuiltinType.Other << 8 | BuiltinType.Number:\n            return this.reportError('Expected a number type', ast.left);\n          case BuiltinType.Number << 8 | BuiltinType.Boolean:\n          case BuiltinType.Number << 8 | BuiltinType.Other:\n            return this.reportError('Expected a number type', ast.right);\n          default:\n            return this.reportError('Expected operands to be a string or number type', ast);\n        }\n      case '>':\n      case '<':\n      case '<=':\n      case '>=':\n      case '==':\n      case '!=':\n      case '===':\n      case '!==':\n        switch (operKind) {\n          case BuiltinType.Any << 8 | BuiltinType.Any:\n          case BuiltinType.Any << 8 | BuiltinType.Boolean:\n          case BuiltinType.Any << 8 | BuiltinType.Number:\n          case BuiltinType.Any << 8 | BuiltinType.String:\n          case BuiltinType.Any << 8 | BuiltinType.Other:\n          case BuiltinType.Boolean << 8 | BuiltinType.Any:\n          case BuiltinType.Boolean << 8 | BuiltinType.Boolean:\n          case BuiltinType.Number << 8 | BuiltinType.Any:\n          case BuiltinType.Number << 8 | BuiltinType.Number:\n          case BuiltinType.String << 8 | BuiltinType.Any:\n          case BuiltinType.String << 8 | BuiltinType.String:\n          case BuiltinType.Other << 8 | BuiltinType.Any:\n          case BuiltinType.Other << 8 | BuiltinType.Other:\n            return this.query.getBuiltinType(BuiltinType.Boolean);\n          default:\n            return this.reportError('Expected the operants to be of similar type or any', ast);\n        }\n      case '&&':\n        return rightType;\n      case '||':\n        return this.query.getTypeUnion(leftType, rightType);\n    }\n\n    return this.reportError(`Unrecognized operator ${ast.operation}`, ast);\n  }\n\n  visitChain(ast: Chain) {\n    if (this.diagnostics) {\n      // If we are producing diagnostics, visit the children\n      visitChildren(ast, this);\n    }\n    // The type of a chain is always undefined.\n    return this.query.getBuiltinType(BuiltinType.Undefined);\n  }\n\n  visitConditional(ast: Conditional) {\n    // The type of a conditional is the union of the true and false conditions.\n    return this.query.getTypeUnion(this.getType(ast.trueExp), this.getType(ast.falseExp));\n  }\n\n  visitFunctionCall(ast: FunctionCall) {\n    // The type of a function call is the return type of the selected signature.\n    // The signature is selected based on the types of the arguments. Angular doesn't\n    // support contextual typing of arguments so this is simpler than TypeScript's\n    // version.\n    const args = ast.args.map(arg => this.getType(arg));\n    const target = this.getType(ast.target);\n    if (!target || !target.callable) return this.reportError('Call target is not callable', ast);\n    const signature = target.selectSignature(args);\n    if (signature) return signature.result;\n    // TODO: Consider a better error message here.\n    return this.reportError('Unable no compatible signature found for call', ast);\n  }\n\n  visitImplicitReceiver(ast: ImplicitReceiver): Symbol {\n    const _this = this;\n    // Return a pseudo-symbol for the implicit receiver.\n    // The members of the implicit receiver are what is defined by the\n    // scope passed into this class.\n    return {\n      name: '$implict',\n      kind: 'component',\n      language: 'ng-template',\n      type: undefined,\n      container: undefined,\n      callable: false,\n      public: true,\n      definition: undefined,\n      members(): SymbolTable{return _this.scope;},\n      signatures(): Signature[]{return [];},\n      selectSignature(types): Signature | undefined{return undefined;},\n      indexed(argument): Symbol | undefined{return undefined;}\n    };\n  }\n\n  visitInterpolation(ast: Interpolation): Symbol {\n    // If we are producing diagnostics, visit the children.\n    if (this.diagnostics) {\n      visitChildren(ast, this);\n    }\n    return this.undefinedType;\n  }\n\n  visitKeyedRead(ast: KeyedRead): Symbol {\n    const targetType = this.getType(ast.obj);\n    const keyType = this.getType(ast.key);\n    const result = targetType.indexed(keyType);\n    return result || this.anyType;\n  }\n\n  visitKeyedWrite(ast: KeyedWrite): Symbol {\n    // The write of a type is the type of the value being written.\n    return this.getType(ast.value);\n  }\n\n  visitLiteralArray(ast: LiteralArray): Symbol {\n    // A type literal is an array type of the union of the elements\n    return this.query.getArrayType(\n        this.query.getTypeUnion(...ast.expressions.map(element => this.getType(element))));\n  }\n\n  visitLiteralMap(ast: LiteralMap): Symbol {\n    // If we are producing diagnostics, visit the children\n    if (this.diagnostics) {\n      visitChildren(ast, this);\n    }\n    // TODO: Return a composite type.\n    return this.anyType;\n  }\n\n  visitLiteralPrimitive(ast: LiteralPrimitive) {\n    // The type of a literal primitive depends on the value of the literal.\n    switch (ast.value) {\n      case true:\n      case false:\n        return this.query.getBuiltinType(BuiltinType.Boolean);\n      case null:\n        return this.query.getBuiltinType(BuiltinType.Null);\n      default:\n        switch (typeof ast.value) {\n          case 'string':\n            return this.query.getBuiltinType(BuiltinType.String);\n          case 'number':\n            return this.query.getBuiltinType(BuiltinType.Number);\n          default:\n            return this.reportError('Unrecognized primitive', ast);\n        }\n    }\n  }\n\n  visitMethodCall(ast: MethodCall) {\n    return this.resolveMethodCall(this.getType(ast.receiver), ast);\n  }\n\n  visitPipe(ast: BindingPipe) {\n    // The type of a pipe node is the return type of the pipe's transform method. The table returned\n    // by getPipes() is expected to contain symbols with the corresponding transform method type.\n    const pipe = this.query.getPipes().get(ast.name);\n    if (!pipe) return this.reportError(`No pipe by the name ${pipe.name} found`, ast);\n    const expType = this.getType(ast.exp);\n    const signature =\n        pipe.selectSignature([expType].concat(ast.args.map(arg => this.getType(arg))));\n    if (!signature) return this.reportError('Unable to resolve signature for pipe invocation', ast);\n    return signature.result;\n  }\n\n  visitPrefixNot(ast: PrefixNot) {\n    // The type of a prefix ! is always boolean.\n    return this.query.getBuiltinType(BuiltinType.Boolean);\n  }\n\n  visitPropertyRead(ast: PropertyRead) {\n    return this.resolvePropertyRead(this.getType(ast.receiver), ast);\n  }\n\n  visitPropertyWrite(ast: PropertyWrite) {\n    // The type of a write is the type of the value being written.\n    return this.getType(ast.value);\n  }\n\n  visitQuote(ast: Quote) {\n    // The type of a quoted expression is any.\n    return this.query.getBuiltinType(BuiltinType.Any);\n  }\n\n  visitSafeMethodCall(ast: SafeMethodCall) {\n    return this.resolveMethodCall(this.query.getNonNullableType(this.getType(ast.receiver)), ast);\n  }\n\n  visitSafePropertyRead(ast: SafePropertyRead) {\n    return this.resolvePropertyRead(this.query.getNonNullableType(this.getType(ast.receiver)), ast);\n  }\n\n  private _anyType: Symbol;\n  private get anyType(): Symbol {\n    let result = this._anyType;\n    if (!result) {\n      result = this._anyType = this.query.getBuiltinType(BuiltinType.Any);\n    }\n    return result;\n  }\n\n  private _undefinedType: Symbol;\n  private get undefinedType(): Symbol {\n    let result = this._undefinedType;\n    if (!result) {\n      result = this._undefinedType = this.query.getBuiltinType(BuiltinType.Undefined);\n    }\n    return result;\n  }\n\n  private resolveMethodCall(receiverType: Symbol, ast: SafeMethodCall|MethodCall) {\n    if (this.isAny(receiverType)) {\n      return this.anyType;\n    }\n\n    // The type of a method is the selected methods result type.\n    const method = receiverType.members().get(ast.name);\n    if (!method) return this.reportError(`Unknown method ${ast.name}`, ast);\n    if (!method.type.callable) return this.reportError(`Member ${ast.name} is not callable`, ast);\n    const signature = method.type.selectSignature(ast.args.map(arg => this.getType(arg)));\n    if (!signature)\n      return this.reportError(`Unable to resolve signature for call of method ${ast.name}`, ast);\n    return signature.result;\n  }\n\n  private resolvePropertyRead(receiverType: Symbol, ast: SafePropertyRead|PropertyRead) {\n    if (this.isAny(receiverType)) {\n      return this.anyType;\n    }\n\n    // The type of a property read is the seelcted member's type.\n    const member = receiverType.members().get(ast.name);\n    if (!member) {\n      let receiverInfo = receiverType.name;\n      if (receiverInfo == '$implict') {\n        receiverInfo =\n            'The component declaration, template variable declarations, and element references do';\n      } else {\n        receiverInfo = `'${receiverInfo}' does`;\n      }\n      return this.reportError(\n          `Identifier '${ast.name}' is not defined. ${receiverInfo} not contain such a member`,\n          ast);\n    }\n    if (!member.public) {\n      let receiverInfo = receiverType.name;\n      if (receiverInfo == '$implict') {\n        receiverInfo = 'the component';\n      } else {\n        receiverInfo = `'${receiverInfo}'`;\n      }\n      this.reportWarning(\n          `Identifier '${ast.name}' refers to a private member of ${receiverInfo}`, ast);\n    }\n    return member.type;\n  }\n\n  private reportError(message: string, ast: AST): Symbol {\n    if (this.diagnostics) {\n      this.diagnostics.push(new TypeDiagnostic(DiagnosticKind.Error, message, ast));\n    }\n    return this.anyType;\n  }\n\n  private reportWarning(message: string, ast: AST): Symbol {\n    if (this.diagnostics) {\n      this.diagnostics.push(new TypeDiagnostic(DiagnosticKind.Warning, message, ast));\n    }\n    return this.anyType;\n  }\n\n  private isAny(symbol: Symbol): boolean {\n    return !symbol || this.query.getTypeKind(symbol) == BuiltinType.Any ||\n        (symbol.type && this.isAny(symbol.type));\n  }\n}\n\nclass AstPath extends AstPathBase<AST> {\n  constructor(ast: AST, public position: number, excludeEmpty: boolean = false) {\n    super(new AstPathVisitor(position, excludeEmpty).buildPath(ast).path);\n  }\n}\n\nclass AstPathVisitor extends NullVisitor {\n  public path: AST[] = [];\n\n  constructor(private position: number, private excludeEmpty: boolean) { super(); }\n\n  visit(ast: AST) {\n    if ((!this.excludeEmpty || ast.span.start < ast.span.end) && inSpan(this.position, ast.span)) {\n      this.path.push(ast);\n      visitChildren(ast, this);\n    }\n  }\n\n  buildPath(ast: AST): AstPathVisitor {\n    // We never care about the ASTWithSource node and its visit() method calls its ast's visit so\n    // the visit() method above would never see it.\n    if (ast instanceof ASTWithSource) {\n      ast = ast.ast;\n    }\n    this.visit(ast);\n    return this;\n  }\n}\n\n// TODO: Consider moving to expression_parser/ast\nfunction visitChildren(ast: AST, visitor: ExpressionVisitor) {\n  function visit(ast: AST) { visitor.visit && visitor.visit(ast) || ast.visit(visitor); }\n\n  function visitAll<T extends AST>(asts: T[]) { asts.forEach(visit); }\n\n  ast.visit({\n    visitBinary(ast) {\n      visit(ast.left);\n      visit(ast.right);\n    },\n    visitChain(ast) { visitAll(ast.expressions); },\n    visitConditional(ast) {\n      visit(ast.condition);\n      visit(ast.trueExp);\n      visit(ast.falseExp);\n    },\n    visitFunctionCall(ast) {\n      visit(ast.target);\n      visitAll(ast.args);\n    },\n    visitImplicitReceiver(ast) {},\n    visitInterpolation(ast) { visitAll(ast.expressions); },\n    visitKeyedRead(ast) {\n      visit(ast.obj);\n      visit(ast.key);\n    },\n    visitKeyedWrite(ast) {\n      visit(ast.obj);\n      visit(ast.key);\n      visit(ast.obj);\n    },\n    visitLiteralArray(ast) { visitAll(ast.expressions); },\n    visitLiteralMap(ast) {},\n    visitLiteralPrimitive(ast) {},\n    visitMethodCall(ast) {\n      visit(ast.receiver);\n      visitAll(ast.args);\n    },\n    visitPipe(ast) {\n      visit(ast.exp);\n      visitAll(ast.args);\n    },\n    visitPrefixNot(ast) { visit(ast.expression); },\n    visitPropertyRead(ast) { visit(ast.receiver); },\n    visitPropertyWrite(ast) {\n      visit(ast.receiver);\n      visit(ast.value);\n    },\n    visitQuote(ast) {},\n    visitSafeMethodCall(ast) {\n      visit(ast.receiver);\n      visitAll(ast.args);\n    },\n    visitSafePropertyRead(ast) { visit(ast.receiver); },\n  });\n}\n\nexport function getExpressionScope(\n    info: TemplateInfo, path: TemplateAstPath, includeEvent: boolean): SymbolTable {\n  let result = info.template.members;\n  const references = getReferences(info);\n  const variables = getVarDeclarations(info, path);\n  const events = getEventDeclaration(info, path, includeEvent);\n  if (references.length || variables.length || events.length) {\n    const referenceTable = info.template.query.createSymbolTable(references);\n    const variableTable = info.template.query.createSymbolTable(variables);\n    const eventsTable = info.template.query.createSymbolTable(events);\n    result =\n        info.template.query.mergeSymbolTable([result, referenceTable, variableTable, eventsTable]);\n  }\n  return result;\n}\n\nfunction getEventDeclaration(info: TemplateInfo, path: TemplateAstPath, includeEvent?: boolean) {\n  let result: SymbolDeclaration[] = [];\n  if (includeEvent) {\n    // TODO: Determine the type of the event parameter based on the Observable<T> or EventEmitter<T>\n    // of the event.\n    result = [{\n      name: '$event',\n      kind: 'variable',\n      type: info.template.query.getBuiltinType(BuiltinType.Any)\n    }];\n  }\n  return result;\n}\n\nfunction getReferences(info: TemplateInfo): SymbolDeclaration[] {\n  const result: SymbolDeclaration[] = [];\n\n  function processReferences(references: ReferenceAst[]) {\n    for (const reference of references) {\n      let type: Symbol;\n      if (reference.value) {\n        type = info.template.query.getTypeSymbol(tokenReference(reference.value));\n      }\n      result.push({\n        name: reference.name,\n        kind: 'reference',\n        type: type || info.template.query.getBuiltinType(BuiltinType.Any),\n        get definition() { return getDefintionOf(info, reference); }\n      });\n    }\n  }\n\n  const visitor = new class extends TemplateAstChildVisitor {\n    visitEmbeddedTemplate(ast: EmbeddedTemplateAst, context: any): any {\n      super.visitEmbeddedTemplate(ast, context);\n      processReferences(ast.references);\n    }\n    visitElement(ast: ElementAst, context: any): any {\n      super.visitElement(ast, context);\n      processReferences(ast.references);\n    }\n  };\n\n  templateVisitAll(visitor, info.templateAst);\n\n  return result;\n}\n\nfunction getVarDeclarations(info: TemplateInfo, path: TemplateAstPath): SymbolDeclaration[] {\n  const result: SymbolDeclaration[] = [];\n\n  let current = path.tail;\n  while (current) {\n    if (current instanceof EmbeddedTemplateAst) {\n      for (const variable of current.variables) {\n        const name = variable.name;\n\n        // Find the first directive with a context.\n        const context =\n            current.directives\n                .map(d => info.template.query.getTemplateContext(d.directive.type.reference))\n                .find(c => !!c);\n\n        // Determine the type of the context field referenced by variable.value.\n        let type: Symbol;\n        if (context) {\n          const value = context.get(variable.value);\n          if (value) {\n            type = value.type;\n            if (info.template.query.getTypeKind(type) === BuiltinType.Any) {\n              // The any type is not very useful here. For special cases, such as ngFor, we can do\n              // better.\n              type = refinedVariableType(type, info, current);\n            }\n          }\n        }\n        if (!type) {\n          type = info.template.query.getBuiltinType(BuiltinType.Any);\n        }\n        result.push({\n          name,\n          kind: 'variable', type, get definition() { return getDefintionOf(info, variable); }\n        });\n      }\n    }\n    current = path.parentOf(current);\n  }\n\n  return result;\n}\n\nfunction refinedVariableType(\n    type: Symbol, info: TemplateInfo, templateElement: EmbeddedTemplateAst): Symbol {\n  // Special case the ngFor directive\n  const ngForDirective =\n      templateElement.directives.find(d => identifierName(d.directive.type) == 'NgFor');\n  if (ngForDirective) {\n    const ngForOfBinding = ngForDirective.inputs.find(i => i.directiveName == 'ngForOf');\n    if (ngForOfBinding) {\n      const bindingType =\n          new AstType(info.template.members, info.template.query).getType(ngForOfBinding.value);\n      if (bindingType) {\n        return info.template.query.getElementType(bindingType);\n      }\n    }\n  }\n\n  // We can't do better, just return the original type.\n  return type;\n}\n\nfunction getDefintionOf(info: TemplateInfo, ast: TemplateAst): Definition {\n  if (info.fileName) {\n    const templateOffset = info.template.span.start;\n    return [{\n      fileName: info.fileName,\n      span: {\n        start: ast.sourceSpan.start.offset + templateOffset,\n        end: ast.sourceSpan.end.offset + templateOffset\n      }\n    }];\n  }\n}\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}