{"version":3,"file":"expressions.js","sourceRoot":"","sources":["../../../../modules/@angular/language-service/src/expressions.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {StaticSymbol, identifierName, tokenReference} from '@angular/compiler';\nimport {AST, ASTWithSource, AstVisitor, Binary, BindingPipe, Chain, Conditional, FunctionCall, ImplicitReceiver, Interpolation, KeyedRead, KeyedWrite, LiteralArray, LiteralMap, LiteralPrimitive, MethodCall, PrefixNot, PropertyRead, PropertyWrite, Quote, SafeMethodCall, SafePropertyRead} from '@angular/compiler/src/expression_parser/ast';\nimport {ElementAst, EmbeddedTemplateAst, ReferenceAst, TemplateAst, templateVisitAll} from '@angular/compiler/src/template_parser/template_ast';\n\nimport {AstPath as AstPathBase} from './ast_path';\nimport {TemplateInfo} from './common';\nimport {TemplateAstChildVisitor, TemplateAstPath} from './template_path';\nimport {BuiltinType, CompletionKind, Definition, DiagnosticKind, Signature, Span, Symbol, SymbolDeclaration, SymbolQuery, SymbolTable} from './types';\nimport {inSpan, spanOf} from './utils';\n\nexport interface ExpressionDiagnosticsContext { event?: boolean; }\n\nexport function getExpressionDiagnostics(\n    scope: SymbolTable, ast: AST, query: SymbolQuery,\n    context: ExpressionDiagnosticsContext = {}): TypeDiagnostic[] {\n  const analyzer = new AstType(scope, query, context);\n  analyzer.getDiagnostics(ast);\n  return analyzer.diagnostics;\n}\n\nexport function getExpressionCompletions(\n    scope: SymbolTable, ast: AST, position: number, query: SymbolQuery): Symbol[] {\n  const path = new AstPath(ast, position);\n  if (path.empty) return undefined;\n  const tail = path.tail;\n  let result: SymbolTable|undefined = scope;\n\n  function getType(ast: AST): Symbol { return new AstType(scope, query, {}).getType(ast); }\n\n  // If the completion request is in a not in a pipe or property access then the global scope\n  // (that is the scope of the implicit receiver) is the right scope as the user is typing the\n  // beginning of an expression.\n  tail.visit({\n    visitBinary(ast) {},\n    visitChain(ast) {},\n    visitConditional(ast) {},\n    visitFunctionCall(ast) {},\n    visitImplicitReceiver(ast) {},\n    visitInterpolation(ast) { result = undefined; },\n    visitKeyedRead(ast) {},\n    visitKeyedWrite(ast) {},\n    visitLiteralArray(ast) {},\n    visitLiteralMap(ast) {},\n    visitLiteralPrimitive(ast) {},\n    visitMethodCall(ast) {},\n    visitPipe(ast) {\n      if (position >= ast.exp.span.end &&\n          (!ast.args || !ast.args.length || position < (<AST>ast.args[0]).span.start)) {\n        // We are in a position a pipe name is expected.\n        result = query.getPipes();\n      }\n    },\n    visitPrefixNot(ast) {},\n    visitPropertyRead(ast) {\n      const receiverType = getType(ast.receiver);\n      result = receiverType ? receiverType.members() : scope;\n    },\n    visitPropertyWrite(ast) {\n      const receiverType = getType(ast.receiver);\n      result = receiverType ? receiverType.members() : scope;\n    },\n    visitQuote(ast) {\n      // For a quote, return the members of any (if there are any).\n      result = query.getBuiltinType(BuiltinType.Any).members();\n    },\n    visitSafeMethodCall(ast) {\n      const receiverType = getType(ast.receiver);\n      result = receiverType ? receiverType.members() : scope;\n    },\n    visitSafePropertyRead(ast) {\n      const receiverType = getType(ast.receiver);\n      result = receiverType ? receiverType.members() : scope;\n    },\n  });\n\n  return result && result.values();\n}\n\nexport function getExpressionSymbol(\n    scope: SymbolTable, ast: AST, position: number,\n    query: SymbolQuery): {symbol: Symbol, span: Span} {\n  const path = new AstPath(ast, position, /* excludeEmpty */ true);\n  if (path.empty) return undefined;\n  const tail = path.tail;\n\n  function getType(ast: AST): Symbol { return new AstType(scope, query, {}).getType(ast); }\n\n  let symbol: Symbol = undefined;\n  let span: Span = undefined;\n\n  // If the completion request is in a not in a pipe or property access then the global scope\n  // (that is the scope of the implicit receiver) is the right scope as the user is typing the\n  // beginning of an expression.\n  tail.visit({\n    visitBinary(ast) {},\n    visitChain(ast) {},\n    visitConditional(ast) {},\n    visitFunctionCall(ast) {},\n    visitImplicitReceiver(ast) {},\n    visitInterpolation(ast) {},\n    visitKeyedRead(ast) {},\n    visitKeyedWrite(ast) {},\n    visitLiteralArray(ast) {},\n    visitLiteralMap(ast) {},\n    visitLiteralPrimitive(ast) {},\n    visitMethodCall(ast) {\n      const receiverType = getType(ast.receiver);\n      symbol = receiverType && receiverType.members().get(ast.name);\n      span = ast.span;\n    },\n    visitPipe(ast) {\n      if (position >= ast.exp.span.end &&\n          (!ast.args || !ast.args.length || position < (<AST>ast.args[0]).span.start)) {\n        // We are in a position a pipe name is expected.\n        const pipes = query.getPipes();\n        if (pipes) {\n          symbol = pipes.get(ast.name);\n          span = ast.span;\n        }\n      }\n    },\n    visitPrefixNot(ast) {},\n    visitPropertyRead(ast) {\n      const receiverType = getType(ast.receiver);\n      symbol = receiverType && receiverType.members().get(ast.name);\n      span = ast.span;\n    },\n    visitPropertyWrite(ast) {\n      const receiverType = getType(ast.receiver);\n      symbol = receiverType && receiverType.members().get(ast.name);\n      span = ast.span;\n    },\n    visitQuote(ast) {},\n    visitSafeMethodCall(ast) {\n      const receiverType = getType(ast.receiver);\n      symbol = receiverType && receiverType.members().get(ast.name);\n      span = ast.span;\n    },\n    visitSafePropertyRead(ast) {\n      const receiverType = getType(ast.receiver);\n      symbol = receiverType && receiverType.members().get(ast.name);\n      span = ast.span;\n    },\n  });\n\n  if (symbol && span) {\n    return {symbol, span};\n  }\n}\n\ninterface ExpressionVisitor extends AstVisitor {\n  visit?(ast: AST, context?: any): any;\n}\n\n\n// Consider moving to expression_parser/ast\nclass NullVisitor implements ExpressionVisitor {\n  visitBinary(ast: Binary): void {}\n  visitChain(ast: Chain): void {}\n  visitConditional(ast: Conditional): void {}\n  visitFunctionCall(ast: FunctionCall): void {}\n  visitImplicitReceiver(ast: ImplicitReceiver): void {}\n  visitInterpolation(ast: Interpolation): void {}\n  visitKeyedRead(ast: KeyedRead): void {}\n  visitKeyedWrite(ast: KeyedWrite): void {}\n  visitLiteralArray(ast: LiteralArray): void {}\n  visitLiteralMap(ast: LiteralMap): void {}\n  visitLiteralPrimitive(ast: LiteralPrimitive): void {}\n  visitMethodCall(ast: MethodCall): void {}\n  visitPipe(ast: BindingPipe): void {}\n  visitPrefixNot(ast: PrefixNot): void {}\n  visitPropertyRead(ast: PropertyRead): void {}\n  visitPropertyWrite(ast: PropertyWrite): void {}\n  visitQuote(ast: Quote): void {}\n  visitSafeMethodCall(ast: SafeMethodCall): void {}\n  visitSafePropertyRead(ast: SafePropertyRead): void {}\n}\n\nexport class TypeDiagnostic {\n  constructor(public kind: DiagnosticKind, public message: string, public ast: AST) {}\n}\n\n// AstType calculatetype of the ast given AST element.\nclass AstType implements ExpressionVisitor {\n  public diagnostics: TypeDiagnostic[];\n\n  constructor(\n      private scope: SymbolTable, private query: SymbolQuery,\n      private context: ExpressionDiagnosticsContext) {}\n\n  getType(ast: AST): Symbol { return ast.visit(this); }\n\n  getDiagnostics(ast: AST): TypeDiagnostic[] {\n    this.diagnostics = [];\n    const type: Symbol = ast.visit(this);\n    if (this.context.event && type.callable) {\n      this.reportWarning('Unexpected callable expression. Expected a method call', ast);\n    }\n    return this.diagnostics;\n  }\n\n  visitBinary(ast: Binary): Symbol {\n    // Treat undefined and null as other.\n    function normalize(kind: BuiltinType, other: BuiltinType): BuiltinType {\n      switch (kind) {\n        case BuiltinType.Undefined:\n        case BuiltinType.Null:\n          return normalize(other, BuiltinType.Other);\n      }\n      return kind;\n    }\n\n    const leftType = this.getType(ast.left);\n    const rightType = this.getType(ast.right);\n    const leftRawKind = this.query.getTypeKind(leftType);\n    const rightRawKind = this.query.getTypeKind(rightType);\n    const leftKind = normalize(leftRawKind, rightRawKind);\n    const rightKind = normalize(rightRawKind, leftRawKind);\n\n    // The following swtich implements operator typing similar to the\n    // type production tables in the TypeScript specification.\n    // https://github.com/Microsoft/TypeScript/blob/v1.8.10/doc/spec.md#4.19\n    const operKind = leftKind << 8 | rightKind;\n    switch (ast.operation) {\n      case '*':\n      case '/':\n      case '%':\n      case '-':\n      case '<<':\n      case '>>':\n      case '>>>':\n      case '&':\n      case '^':\n      case '|':\n        switch (operKind) {\n          case BuiltinType.Any << 8 | BuiltinType.Any:\n          case BuiltinType.Number << 8 | BuiltinType.Any:\n          case BuiltinType.Any << 8 | BuiltinType.Number:\n          case BuiltinType.Number << 8 | BuiltinType.Number:\n            return this.query.getBuiltinType(BuiltinType.Number);\n          default:\n            let errorAst = ast.left;\n            switch (leftKind) {\n              case BuiltinType.Any:\n              case BuiltinType.Number:\n                errorAst = ast.right;\n                break;\n            }\n            return this.reportError('Expected a numeric type', errorAst);\n        }\n      case '+':\n        switch (operKind) {\n          case BuiltinType.Any << 8 | BuiltinType.Any:\n          case BuiltinType.Any << 8 | BuiltinType.Boolean:\n          case BuiltinType.Any << 8 | BuiltinType.Number:\n          case BuiltinType.Any << 8 | BuiltinType.Other:\n          case BuiltinType.Boolean << 8 | BuiltinType.Any:\n          case BuiltinType.Number << 8 | BuiltinType.Any:\n          case BuiltinType.Other << 8 | BuiltinType.Any:\n            return this.anyType;\n          case BuiltinType.Any << 8 | BuiltinType.String:\n          case BuiltinType.Boolean << 8 | BuiltinType.String:\n          case BuiltinType.Number << 8 | BuiltinType.String:\n          case BuiltinType.String << 8 | BuiltinType.Any:\n          case BuiltinType.String << 8 | BuiltinType.Boolean:\n          case BuiltinType.String << 8 | BuiltinType.Number:\n          case BuiltinType.String << 8 | BuiltinType.String:\n          case BuiltinType.String << 8 | BuiltinType.Other:\n          case BuiltinType.Other << 8 | BuiltinType.String:\n            return this.query.getBuiltinType(BuiltinType.String);\n          case BuiltinType.Number << 8 | BuiltinType.Number:\n            return this.query.getBuiltinType(BuiltinType.Number);\n          case BuiltinType.Boolean << 8 | BuiltinType.Number:\n          case BuiltinType.Other << 8 | BuiltinType.Number:\n            return this.reportError('Expected a number type', ast.left);\n          case BuiltinType.Number << 8 | BuiltinType.Boolean:\n          case BuiltinType.Number << 8 | BuiltinType.Other:\n            return this.reportError('Expected a number type', ast.right);\n          default:\n            return this.reportError('Expected operands to be a string or number type', ast);\n        }\n      case '>':\n      case '<':\n      case '<=':\n      case '>=':\n      case '==':\n      case '!=':\n      case '===':\n      case '!==':\n        switch (operKind) {\n          case BuiltinType.Any << 8 | BuiltinType.Any:\n          case BuiltinType.Any << 8 | BuiltinType.Boolean:\n          case BuiltinType.Any << 8 | BuiltinType.Number:\n          case BuiltinType.Any << 8 | BuiltinType.String:\n          case BuiltinType.Any << 8 | BuiltinType.Other:\n          case BuiltinType.Boolean << 8 | BuiltinType.Any:\n          case BuiltinType.Boolean << 8 | BuiltinType.Boolean:\n          case BuiltinType.Number << 8 | BuiltinType.Any:\n          case BuiltinType.Number << 8 | BuiltinType.Number:\n          case BuiltinType.String << 8 | BuiltinType.Any:\n          case BuiltinType.String << 8 | BuiltinType.String:\n          case BuiltinType.Other << 8 | BuiltinType.Any:\n          case BuiltinType.Other << 8 | BuiltinType.Other:\n            return this.query.getBuiltinType(BuiltinType.Boolean);\n          default:\n            return this.reportError('Expected the operants to be of similar type or any', ast);\n        }\n      case '&&':\n        return rightType;\n      case '||':\n        return this.query.getTypeUnion(leftType, rightType);\n    }\n\n    return this.reportError(`Unrecognized operator ${ast.operation}`, ast);\n  }\n\n  visitChain(ast: Chain) {\n    if (this.diagnostics) {\n      // If we are producing diagnostics, visit the children\n      visitChildren(ast, this);\n    }\n    // The type of a chain is always undefined.\n    return this.query.getBuiltinType(BuiltinType.Undefined);\n  }\n\n  visitConditional(ast: Conditional) {\n    // The type of a conditional is the union of the true and false conditions.\n    return this.query.getTypeUnion(this.getType(ast.trueExp), this.getType(ast.falseExp));\n  }\n\n  visitFunctionCall(ast: FunctionCall) {\n    // The type of a function call is the return type of the selected signature.\n    // The signature is selected based on the types of the arguments. Angular doesn't\n    // support contextual typing of arguments so this is simpler than TypeScript's\n    // version.\n    const args = ast.args.map(arg => this.getType(arg));\n    const target = this.getType(ast.target);\n    if (!target || !target.callable) return this.reportError('Call target is not callable', ast);\n    const signature = target.selectSignature(args);\n    if (signature) return signature.result;\n    // TODO: Consider a better error message here.\n    return this.reportError('Unable no compatible signature found for call', ast);\n  }\n\n  visitImplicitReceiver(ast: ImplicitReceiver): Symbol {\n    const _this = this;\n    // Return a pseudo-symbol for the implicit receiver.\n    // The members of the implicit receiver are what is defined by the\n    // scope passed into this class.\n    return {\n      name: '$implict',\n      kind: 'component',\n      language: 'ng-template',\n      type: undefined,\n      container: undefined,\n      callable: false,\n      public: true,\n      definition: undefined,\n      members(): SymbolTable{return _this.scope;},\n      signatures(): Signature[]{return [];},\n      selectSignature(types): Signature | undefined{return undefined;},\n      indexed(argument): Symbol | undefined{return undefined;}\n    };\n  }\n\n  visitInterpolation(ast: Interpolation): Symbol {\n    // If we are producing diagnostics, visit the children.\n    if (this.diagnostics) {\n      visitChildren(ast, this);\n    }\n    return this.undefinedType;\n  }\n\n  visitKeyedRead(ast: KeyedRead): Symbol {\n    const targetType = this.getType(ast.obj);\n    const keyType = this.getType(ast.key);\n    const result = targetType.indexed(keyType);\n    return result || this.anyType;\n  }\n\n  visitKeyedWrite(ast: KeyedWrite): Symbol {\n    // The write of a type is the type of the value being written.\n    return this.getType(ast.value);\n  }\n\n  visitLiteralArray(ast: LiteralArray): Symbol {\n    // A type literal is an array type of the union of the elements\n    return this.query.getArrayType(\n        this.query.getTypeUnion(...ast.expressions.map(element => this.getType(element))));\n  }\n\n  visitLiteralMap(ast: LiteralMap): Symbol {\n    // If we are producing diagnostics, visit the children\n    if (this.diagnostics) {\n      visitChildren(ast, this);\n    }\n    // TODO: Return a composite type.\n    return this.anyType;\n  }\n\n  visitLiteralPrimitive(ast: LiteralPrimitive) {\n    // The type of a literal primitive depends on the value of the literal.\n    switch (ast.value) {\n      case true:\n      case false:\n        return this.query.getBuiltinType(BuiltinType.Boolean);\n      case null:\n        return this.query.getBuiltinType(BuiltinType.Null);\n      case undefined:\n        return this.query.getBuiltinType(BuiltinType.Undefined);\n      default:\n        switch (typeof ast.value) {\n          case 'string':\n            return this.query.getBuiltinType(BuiltinType.String);\n          case 'number':\n            return this.query.getBuiltinType(BuiltinType.Number);\n          default:\n            return this.reportError('Unrecognized primitive', ast);\n        }\n    }\n  }\n\n  visitMethodCall(ast: MethodCall) {\n    return this.resolveMethodCall(this.getType(ast.receiver), ast);\n  }\n\n  visitPipe(ast: BindingPipe) {\n    // The type of a pipe node is the return type of the pipe's transform method. The table returned\n    // by getPipes() is expected to contain symbols with the corresponding transform method type.\n    const pipe = this.query.getPipes().get(ast.name);\n    if (!pipe) return this.reportError(`No pipe by the name ${pipe.name} found`, ast);\n    const expType = this.getType(ast.exp);\n    const signature =\n        pipe.selectSignature([expType].concat(ast.args.map(arg => this.getType(arg))));\n    if (!signature) return this.reportError('Unable to resolve signature for pipe invocation', ast);\n    return signature.result;\n  }\n\n  visitPrefixNot(ast: PrefixNot) {\n    // The type of a prefix ! is always boolean.\n    return this.query.getBuiltinType(BuiltinType.Boolean);\n  }\n\n  visitPropertyRead(ast: PropertyRead) {\n    return this.resolvePropertyRead(this.getType(ast.receiver), ast);\n  }\n\n  visitPropertyWrite(ast: PropertyWrite) {\n    // The type of a write is the type of the value being written.\n    return this.getType(ast.value);\n  }\n\n  visitQuote(ast: Quote) {\n    // The type of a quoted expression is any.\n    return this.query.getBuiltinType(BuiltinType.Any);\n  }\n\n  visitSafeMethodCall(ast: SafeMethodCall) {\n    return this.resolveMethodCall(this.query.getNonNullableType(this.getType(ast.receiver)), ast);\n  }\n\n  visitSafePropertyRead(ast: SafePropertyRead) {\n    return this.resolvePropertyRead(this.query.getNonNullableType(this.getType(ast.receiver)), ast);\n  }\n\n  private _anyType: Symbol;\n  private get anyType(): Symbol {\n    let result = this._anyType;\n    if (!result) {\n      result = this._anyType = this.query.getBuiltinType(BuiltinType.Any);\n    }\n    return result;\n  }\n\n  private _undefinedType: Symbol;\n  private get undefinedType(): Symbol {\n    let result = this._undefinedType;\n    if (!result) {\n      result = this._undefinedType = this.query.getBuiltinType(BuiltinType.Undefined);\n    }\n    return result;\n  }\n\n  private resolveMethodCall(receiverType: Symbol, ast: SafeMethodCall|MethodCall) {\n    if (this.isAny(receiverType)) {\n      return this.anyType;\n    }\n\n    // The type of a method is the selected methods result type.\n    const method = receiverType.members().get(ast.name);\n    if (!method) return this.reportError(`Unknown method ${ast.name}`, ast);\n    if (!method.type.callable) return this.reportError(`Member ${ast.name} is not callable`, ast);\n    const signature = method.type.selectSignature(ast.args.map(arg => this.getType(arg)));\n    if (!signature)\n      return this.reportError(`Unable to resolve signature for call of method ${ast.name}`, ast);\n    return signature.result;\n  }\n\n  private resolvePropertyRead(receiverType: Symbol, ast: SafePropertyRead|PropertyRead) {\n    if (this.isAny(receiverType)) {\n      return this.anyType;\n    }\n\n    // The type of a property read is the seelcted member's type.\n    const member = receiverType.members().get(ast.name);\n    if (!member) {\n      let receiverInfo = receiverType.name;\n      if (receiverInfo == '$implict') {\n        receiverInfo =\n            'The component declaration, template variable declarations, and element references do';\n      } else {\n        receiverInfo = `'${receiverInfo}' does`;\n      }\n      return this.reportError(\n          `Identifier '${ast.name}' is not defined. ${receiverInfo} not contain such a member`,\n          ast);\n    }\n    if (!member.public) {\n      let receiverInfo = receiverType.name;\n      if (receiverInfo == '$implict') {\n        receiverInfo = 'the component';\n      } else {\n        receiverInfo = `'${receiverInfo}'`;\n      }\n      this.reportWarning(\n          `Identifier '${ast.name}' refers to a private member of ${receiverInfo}`, ast);\n    }\n    return member.type;\n  }\n\n  private reportError(message: string, ast: AST): Symbol {\n    if (this.diagnostics) {\n      this.diagnostics.push(new TypeDiagnostic(DiagnosticKind.Error, message, ast));\n    }\n    return this.anyType;\n  }\n\n  private reportWarning(message: string, ast: AST): Symbol {\n    if (this.diagnostics) {\n      this.diagnostics.push(new TypeDiagnostic(DiagnosticKind.Warning, message, ast));\n    }\n    return this.anyType;\n  }\n\n  private isAny(symbol: Symbol): boolean {\n    return !symbol || this.query.getTypeKind(symbol) == BuiltinType.Any ||\n        (symbol.type && this.isAny(symbol.type));\n  }\n}\n\nclass AstPath extends AstPathBase<AST> {\n  constructor(ast: AST, public position: number, excludeEmpty: boolean = false) {\n    super(new AstPathVisitor(position, excludeEmpty).buildPath(ast).path);\n  }\n}\n\nclass AstPathVisitor extends NullVisitor {\n  public path: AST[] = [];\n\n  constructor(private position: number, private excludeEmpty: boolean) { super(); }\n\n  visit(ast: AST) {\n    if ((!this.excludeEmpty || ast.span.start < ast.span.end) && inSpan(this.position, ast.span)) {\n      this.path.push(ast);\n      visitChildren(ast, this);\n    }\n  }\n\n  buildPath(ast: AST): AstPathVisitor {\n    // We never care about the ASTWithSource node and its visit() method calls its ast's visit so\n    // the visit() method above would never see it.\n    if (ast instanceof ASTWithSource) {\n      ast = ast.ast;\n    }\n    this.visit(ast);\n    return this;\n  }\n}\n\n// TODO: Consider moving to expression_parser/ast\nfunction visitChildren(ast: AST, visitor: ExpressionVisitor) {\n  function visit(ast: AST) { visitor.visit && visitor.visit(ast) || ast.visit(visitor); }\n\n  function visitAll<T extends AST>(asts: T[]) { asts.forEach(visit); }\n\n  ast.visit({\n    visitBinary(ast) {\n      visit(ast.left);\n      visit(ast.right);\n    },\n    visitChain(ast) { visitAll(ast.expressions); },\n    visitConditional(ast) {\n      visit(ast.condition);\n      visit(ast.trueExp);\n      visit(ast.falseExp);\n    },\n    visitFunctionCall(ast) {\n      visit(ast.target);\n      visitAll(ast.args);\n    },\n    visitImplicitReceiver(ast) {},\n    visitInterpolation(ast) { visitAll(ast.expressions); },\n    visitKeyedRead(ast) {\n      visit(ast.obj);\n      visit(ast.key);\n    },\n    visitKeyedWrite(ast) {\n      visit(ast.obj);\n      visit(ast.key);\n      visit(ast.obj);\n    },\n    visitLiteralArray(ast) { visitAll(ast.expressions); },\n    visitLiteralMap(ast) {},\n    visitLiteralPrimitive(ast) {},\n    visitMethodCall(ast) {\n      visit(ast.receiver);\n      visitAll(ast.args);\n    },\n    visitPipe(ast) {\n      visit(ast.exp);\n      visitAll(ast.args);\n    },\n    visitPrefixNot(ast) { visit(ast.expression); },\n    visitPropertyRead(ast) { visit(ast.receiver); },\n    visitPropertyWrite(ast) {\n      visit(ast.receiver);\n      visit(ast.value);\n    },\n    visitQuote(ast) {},\n    visitSafeMethodCall(ast) {\n      visit(ast.receiver);\n      visitAll(ast.args);\n    },\n    visitSafePropertyRead(ast) { visit(ast.receiver); },\n  });\n}\n\nexport function getExpressionScope(\n    info: TemplateInfo, path: TemplateAstPath, includeEvent: boolean): SymbolTable {\n  let result = info.template.members;\n  const references = getReferences(info);\n  const variables = getVarDeclarations(info, path);\n  const events = getEventDeclaration(info, path, includeEvent);\n  if (references.length || variables.length || events.length) {\n    const referenceTable = info.template.query.createSymbolTable(references);\n    const variableTable = info.template.query.createSymbolTable(variables);\n    const eventsTable = info.template.query.createSymbolTable(events);\n    result =\n        info.template.query.mergeSymbolTable([result, referenceTable, variableTable, eventsTable]);\n  }\n  return result;\n}\n\nfunction getEventDeclaration(info: TemplateInfo, path: TemplateAstPath, includeEvent?: boolean) {\n  let result: SymbolDeclaration[] = [];\n  if (includeEvent) {\n    // TODO: Determine the type of the event parameter based on the Observable<T> or EventEmitter<T>\n    // of the event.\n    result = [{\n      name: '$event',\n      kind: 'variable',\n      type: info.template.query.getBuiltinType(BuiltinType.Any)\n    }];\n  }\n  return result;\n}\n\nfunction getReferences(info: TemplateInfo): SymbolDeclaration[] {\n  const result: SymbolDeclaration[] = [];\n\n  function processReferences(references: ReferenceAst[]) {\n    for (const reference of references) {\n      let type: Symbol;\n      if (reference.value) {\n        type = info.template.query.getTypeSymbol(tokenReference(reference.value));\n      }\n      result.push({\n        name: reference.name,\n        kind: 'reference',\n        type: type || info.template.query.getBuiltinType(BuiltinType.Any),\n        get definition() { return getDefintionOf(info, reference); }\n      });\n    }\n  }\n\n  const visitor = new class extends TemplateAstChildVisitor {\n    visitEmbeddedTemplate(ast: EmbeddedTemplateAst, context: any): any {\n      super.visitEmbeddedTemplate(ast, context);\n      processReferences(ast.references);\n    }\n    visitElement(ast: ElementAst, context: any): any {\n      super.visitElement(ast, context);\n      processReferences(ast.references);\n    }\n  };\n\n  templateVisitAll(visitor, info.templateAst);\n\n  return result;\n}\n\nfunction getVarDeclarations(info: TemplateInfo, path: TemplateAstPath): SymbolDeclaration[] {\n  const result: SymbolDeclaration[] = [];\n\n  let current = path.tail;\n  while (current) {\n    if (current instanceof EmbeddedTemplateAst) {\n      for (const variable of current.variables) {\n        const name = variable.name;\n\n        // Find the first directive with a context.\n        const context =\n            current.directives\n                .map(d => info.template.query.getTemplateContext(d.directive.type.reference))\n                .find(c => !!c);\n\n        // Determine the type of the context field referenced by variable.value.\n        let type: Symbol;\n        if (context) {\n          const value = context.get(variable.value);\n          if (value) {\n            type = value.type;\n            if (info.template.query.getTypeKind(type) === BuiltinType.Any) {\n              // The any type is not very useful here. For special cases, such as ngFor, we can do\n              // better.\n              type = refinedVariableType(type, info, current);\n            }\n          }\n        }\n        if (!type) {\n          type = info.template.query.getBuiltinType(BuiltinType.Any);\n        }\n        result.push({\n          name,\n          kind: 'variable', type, get definition() { return getDefintionOf(info, variable); }\n        });\n      }\n    }\n    current = path.parentOf(current);\n  }\n\n  return result;\n}\n\nfunction refinedVariableType(\n    type: Symbol, info: TemplateInfo, templateElement: EmbeddedTemplateAst): Symbol {\n  // Special case the ngFor directive\n  const ngForDirective =\n      templateElement.directives.find(d => identifierName(d.directive.type) == 'NgFor');\n  if (ngForDirective) {\n    const ngForOfBinding = ngForDirective.inputs.find(i => i.directiveName == 'ngForOf');\n    if (ngForOfBinding) {\n      const bindingType =\n          new AstType(info.template.members, info.template.query, {}).getType(ngForOfBinding.value);\n      if (bindingType) {\n        return info.template.query.getElementType(bindingType);\n      }\n    }\n  }\n\n  // We can't do better, just return the original type.\n  return type;\n}\n\nfunction getDefintionOf(info: TemplateInfo, ast: TemplateAst): Definition {\n  if (info.fileName) {\n    const templateOffset = info.template.span.start;\n    return [{\n      fileName: info.fileName,\n      span: {\n        start: ast.sourceSpan.start.offset + templateOffset,\n        end: ast.sourceSpan.end.offset + templateOffset\n      }\n    }];\n  }\n}\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}