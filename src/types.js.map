{"version":3,"file":"types.js","sourceRoot":"","sources":["../../../../modules/@angular/language-service/src/types.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAmJH;;;;;;GAMG;AACH,WAAY,WAmCX;AAnCD,WAAY,WAAW;IACrB;;OAEG;IACH,2CAAG,CAAA;IAEH;;OAEG;IACH,iDAAM,CAAA;IAEN;;OAEG;IACH,iDAAM,CAAA;IAEN;;OAEG;IACH,mDAAO,CAAA;IAEP;;OAEG;IACH,uDAAS,CAAA;IAET;;OAEG;IACH,6CAAI,CAAA;IAEJ;;OAEG;IACH,+CAAK,CAAA;AACP,CAAC,EAnCW,WAAW,KAAX,WAAW,QAmCtB;AAiVD;;;;GAIG;AACH,WAAY,cAGX;AAHD,WAAY,cAAc;IACxB,qDAAK,CAAA;IACL,yDAAO,CAAA;AACT,CAAC,EAHW,cAAc,KAAd,cAAc,QAGzB","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {CompileDirectiveMetadata, StaticSymbol} from '@angular/compiler';\nimport {NgAnalyzedModules} from '@angular/compiler/src/aot/compiler';\nimport {CompileMetadataResolver} from '@angular/compiler/src/metadata_resolver';\n\n\n/**\n * The range of a span of text in a source file.\n *\n * @experimental\n */\nexport interface Span {\n  /**\n   * The first code-point of the span as an offset relative to the beginning of the source assuming\n   * a UTF-16 encoding.\n   */\n  start: number;\n\n  /**\n   * The first code-point after the span as an offset relative to the beginning of the source\n   * assuming a UTF-16 encoding.\n   */\n  end: number;\n}\n\n/**\n * The information `LanguageService` needs from the `LanguageServiceHost` to describe the content of\n * a template and the\n * langauge context the template is in.\n *\n * A host interface; see `LanguageSeriviceHost`.\n *\n * @experimental\n */\nexport interface TemplateSource {\n  /**\n   * The source of the template.\n   */\n  readonly source: string;\n\n  /**\n   * The version of the source. As files are modified the version should change. That is, if the\n   * `LanguageSerivce` requesting\n   * template infomration for a source file and that file has changed since the last time the host\n   * was asked for the file then\n   * this version string should be different. No assumptions are made about the format of this\n   * string.\n   *\n   * The version can change more often than the source but should not change less often.\n   */\n  readonly version: string;\n\n  /**\n   * The span of the template within the source file.\n   */\n  readonly span: Span;\n\n  /**\n   * A static symbol for the template's component.\n   */\n  readonly type: StaticSymbol;\n\n  /**\n   * The `SymbolTable` for the members of the component.\n   */\n  readonly members: SymbolTable;\n\n  /**\n   * A `SymbolQuery` for the context of the template.\n   */\n  readonly query: SymbolQuery;\n}\n\n/**\n * A sequence of template sources.\n *\n * A host type; see `LanguageSeriviceHost`.\n *\n * @experimental\n */\nexport type TemplateSources = TemplateSource[] /* | undefined */;\n\n/**\n * Error information found getting declaration information\n *\n * A host type; see `LanagueServiceHost`.\n *\n * @experimental\n */\nexport interface DeclarationError {\n  /**\n   * The span of the error in the declaration's module.\n   */\n  readonly span: Span;\n\n  /**\n   * The message to display describing the error.\n   */\n  readonly message: string;\n}\n\n/**\n * Information about the component declarations.\n *\n * A file might contain a declaration without a template because the file contains only\n * templateUrl references. However, the compoennt declaration might contain errors that\n * need to be reported such as the template string is missing or the component is not\n * declared in a module. These error should be reported on the declaration, not the\n * template.\n *\n * A host type; see `LanguageSeriviceHost`.\n *\n * @experimental\n */\nexport interface Declaration {\n  /**\n   * The static symbol of the compponent being declared.\n   */\n  readonly type: StaticSymbol;\n\n  /**\n   * The span of the declaration annotation reference (e.g. the 'Component' or 'Directive'\n   * reference).\n   */\n  readonly declarationSpan: Span;\n\n  /**\n   * Reference to the compiler directive metadata for the declaration.\n   */\n  readonly metadata?: CompileDirectiveMetadata;\n\n  /**\n   * Error reported trying to get the metadata.\n   */\n  readonly errors: DeclarationError[];\n}\n\n/**\n * A sequence of declarations.\n *\n * A host type; see `LanguageSeriviceHost`.\n *\n * @experimental\n */\nexport type Declarations = Declaration[];\n\n/**\n * An enumeration of basic types.\n *\n * A `LanguageServiceHost` interface.\n *\n * @experimental\n */\nexport enum BuiltinType {\n  /**\n   * The type is a type that can hold any other type.\n   */\n  Any,\n\n  /**\n   * The type of a string literal.\n   */\n  String,\n\n  /**\n   * The type of a numeric literal.\n   */\n  Number,\n\n  /**\n   * The type of the `true` and `false` literals.\n   */\n  Boolean,\n\n  /**\n   * The type of the `undefined` literal.\n   */\n  Undefined,\n\n  /**\n   * the type of the `null` literal.\n   */\n  Null,\n\n  /**\n   * Not a built-in type.\n   */\n  Other\n}\n\n/**\n * A symbol describing a language element that can be referenced by expressions\n * in an Angular template.\n *\n * A `LanguageServiceHost` interface.\n *\n * @experimental\n */\nexport interface Symbol {\n  /**\n   * The name of the symbol as it would be referenced in an Angular expression.\n   */\n  readonly name: string;\n\n  /**\n   * The kind of completion this symbol should generate if included.\n   */\n  readonly kind: string;\n\n  /**\n   * The language of the source that defines the symbol. (e.g. typescript for TypeScript,\n   * ng-template for an Angular template, etc.)\n   */\n  readonly language: string;\n\n  /**\n   * A symbol representing type of the symbol.\n   */\n  readonly type: Symbol /* | undefined */;\n\n\n  /**\n   * A symbol for the container of this symbol. For example, if this is a method, the container\n   * is the class or interface of the method. If no container is appropriate, undefined is\n   * returned.\n   */\n  readonly container: Symbol /* | undefined */;\n\n  /**\n   * The symbol is public in the container.\n   */\n  readonly public: boolean;\n\n  /**\n   * `true` if the symbol can be the target of a call.\n   */\n  readonly callable: boolean;\n\n  /**\n   * The location of the definition of the symbol\n   */\n  readonly definition: Definition;\n  /**\n\n   * A table of the members of the symbol; that is, the members that can appear\n   * after a `.` in an Angular expression.\n   *\n   */\n  members(): SymbolTable;\n\n  /**\n   * The list of overloaded signatures that can be used if the symbol is the\n   * target of a call.\n   */\n  signatures(): Signature[];\n\n  /**\n   * Return which signature of returned by `signatures()` would be used selected\n   * given the `types` supplied. If no signature would match, this method should\n   * return `undefined`.\n   */\n  selectSignature(types: Symbol[]): Signature /* | undefined */;\n\n  /**\n   * Return the type of the expression if this symbol is indexed by `argument`.\n   * If the symbol cannot be indexed, this method should return `undefined`.\n   */\n  indexed(argument: Symbol): Symbol /* | undefined */;\n}\n\n/**\n * A table of `Symbol`s accessible by name.\n *\n * A `LanguageServiceHost` interface.\n *\n * @experimental\n */\nexport interface SymbolTable {\n  /**\n   * The number of symbols in the table.\n   */\n  readonly size: number;\n\n  /**\n   * Get the symbol corresponding to `key` or `undefined` if there is no symbol in the\n   * table by the name `key`.\n   */\n  get(key: string): Symbol /* | undefined */;\n\n  /**\n   * Returns `true` if the table contains a `Symbol` with the name `key`.\n   */\n  has(key: string): boolean;\n\n  /**\n   * Returns all the `Symbol`s in the table. The order should be, but is not required to be,\n   * in declaration order.\n   */\n  values(): Symbol[];\n}\n\n/**\n * A description of a function or method signature.\n *\n * A `LanguageServiceHost` interface.\n *\n * @experimental\n */\nexport interface Signature {\n  /**\n   * The arguments of the signture. The order of `argumetnts.symbols()` must be in the order\n   * of argument declaration.\n   */\n  readonly arguments: SymbolTable;\n\n  /**\n   * The symbol of the signature result type.\n   */\n  readonly result: Symbol;\n}\n\n/**\n * Describes the language context in which an Angular expression is evaluated.\n *\n * A `LanguageServiceHost` interface.\n *\n * @experimental\n */\nexport interface SymbolQuery {\n  /**\n   * Return the built-in type this symbol represents or Other if it is not a built-in type.\n   */\n  getTypeKind(symbol: Symbol): BuiltinType;\n\n  /**\n   * Return a symbol representing the given built-in type.\n   */\n  getBuiltinType(kind: BuiltinType): Symbol;\n\n  /**\n   * Return the symbol for a type that represents the union of all the types given. Any value\n   * of one of the types given should be assignable to the returned type. If no one type can\n   * be constructed then this should be the Any type.\n   */\n  getTypeUnion(...types: Symbol[]): Symbol;\n\n  /**\n   * Return a symbol for an array type that has the `type` as its element type.\n   */\n  getArrayType(type: Symbol): Symbol;\n\n  /**\n   * Return element type symbol for an array type if the `type` is an array type. Otherwise return\n   * undefined.\n   */\n  getElementType(type: Symbol): Symbol /* | undefined */;\n\n  /**\n   * Return a type that is the non-nullable version of the given type. If `type` is already\n   * non-nullable, return `type`.\n   */\n  getNonNullableType(type: Symbol): Symbol;\n\n  /**\n   * Return a symbol table for the pipes that are in scope.\n   */\n  getPipes(): SymbolTable;\n\n  /**\n   * Return the type symbol for the given static symbol.\n   */\n  getTypeSymbol(type: StaticSymbol): Symbol;\n\n  /**\n   * Return the members that are in the context of a type's template reference.\n   */\n  getTemplateContext(type: StaticSymbol): SymbolTable;\n\n  /**\n   * Produce a symbol table with the given symbols. Used to produce a symbol table\n   * for use with mergeSymbolTables().\n   */\n  createSymbolTable(symbols: SymbolDeclaration[]): SymbolTable;\n\n  /**\n   * Produce a merged symbol table. If the symbol tables contain duplicate entries\n   * the entries of the latter symbol tables will obscure the entries in the prior\n   * symbol tables.\n   *\n   * The symbol tables passed to this routine MUST be produces by the same instance\n   * of SymbolQuery that is being called.\n   */\n  mergeSymbolTable(symbolTables: SymbolTable[]): SymbolTable;\n\n  /**\n   * Return the span of the narrowest non-token node at the given location.\n   */\n  getSpanAt(line: number, column: number): Span /* | undefined */;\n}\n\n/**\n * The host for a `LanguageService`. This provides all the `LanguageSerivce` requires to respond to\n * the `LanguageService` requests.\n *\n * This interface describes the requirements of the `LanguageService` on its host.\n *\n * The host interface is host language agnostic.\n *\n * Adding optional member to this interface or any interface that is described as a\n * `LanguageSerivceHost`\n * interface is not considered a breaking change as defined by SemVer. Removing a method or changing\n * a\n * member from required to optional will also not be considered a breaking change.\n *\n * If a member is deprecated it will be changed to optional in a minor release before it is removed\n * in\n * a major release.\n *\n * Adding a required member or changing a method's parameters, is considered a breaking change and\n * will\n * only be done when breaking changes are allowed. When possible, a new optional member will be\n * added and\n * the old member will be deprecated. The new member will then be made required in and the old\n * member will\n * be removed only when breaking chnages are allowed.\n *\n * While an interface is marked as experimental breaking-changes will be allowed between minor\n * releases.\n * After an interface is marked as stable breaking-changes will only be allowed between major\n * releases.\n * No breaking changes are allowed between patch releases.\n *\n * @experimental\n */\nexport interface LanguageServiceHost {\n  /**\n   * The resolver to use to find compiler metadata.\n   */\n  readonly resolver: CompileMetadataResolver;\n\n  /**\n   * Returns the template information for templates in `fileName` at the given location. If\n   * `fileName`\n   * refers to a template file then the `position` should be ignored. If the `position` is not in a\n   * template literal string then this method should return `undefined`.\n   */\n  getTemplateAt(fileName: string, position: number): TemplateSource /* |undefined */;\n\n  /**\n   * Return the template source information for all templates in `fileName` or for `fileName` if it\n   * is\n   * a template file.\n   */\n  getTemplates(fileName: string): TemplateSources;\n\n  /**\n   * Returns the Angular declarations in the given file.\n   */\n  getDeclarations(fileName: string): Declarations;\n\n  /**\n   * Return a summary of all Angular modules in the project.\n   */\n  getAnalyzedModules(): NgAnalyzedModules;\n\n  /**\n   * Return a list all the template files referenced by the project.\n   */\n  getTemplateReferences(): string[];\n}\n\n/**\n * The kinds of completions generated by the language service.\n *\n * A 'LanguageService' interface.\n *\n * @experimental\n */\nexport type CompletionKind = 'attribute' | 'html attribute' | 'component' | 'element' | 'entity' |\n    'key' | 'method' | 'pipe' | 'property' | 'type' | 'reference' | 'variable';\n\n/**\n * An item of the completion result to be displayed by an editor.\n *\n * A `LanguageService` interface.\n *\n * @experimental\n */\nexport interface Completion {\n  /**\n   * The kind of comletion.\n   */\n  kind: CompletionKind;\n\n  /**\n   * The name of the completion to be displayed\n   */\n  name: string;\n\n  /**\n   * The key to use to sort the completions for display.\n   */\n  sort: string;\n}\n\n/**\n * A sequence of completions.\n *\n * @experimental\n */\nexport type Completions = Completion[] /* | undefined */;\n\n/**\n * A file and span.\n */\nexport interface Location {\n  fileName: string;\n  span: Span;\n}\n\n/**\n * A defnition location(s).\n */\nexport type Definition = Location[] /* | undefined */;\n\n/**\n * The kind of diagnostic message.\n *\n * @experimental\n */\nexport enum DiagnosticKind {\n  Error,\n  Warning,\n}\n\n/**\n * An template diagnostic message to display.\n *\n * @experimental\n */\nexport interface Diagnostic {\n  /**\n   * The kind of diagnostic message\n   */\n  kind: DiagnosticKind;\n\n  /**\n   * The source span that should be highlighted.\n   */\n  span: Span;\n\n  /**\n   * The text of the diagnostic message to display.\n   */\n  message: string;\n}\n\n/**\n * A sequence of diagnostic message.\n *\n * @experimental\n */\nexport type Diagnostics = Diagnostic[];\n\n/**\n * Information about the pipes that are available for use in a template.\n *\n * A `LanguageService` interface.\n *\n * @experimental\n */\nexport interface PipeInfo {\n  /**\n   * The name of the pipe.\n   */\n  name: string;\n\n  /**\n   * The static symbol for the pipe's constructor.\n   */\n  symbol: StaticSymbol;\n}\n\n/**\n * A sequence of pipe information.\n *\n * @experimental\n */\nexport type Pipes = PipeInfo[] /* | undefined */;\n\n/**\n * Describes a symbol to type binding used to build a symbol table.\n *\n * A `LanguageServiceHost` interface.\n *\n * @experimental\n */\n\nexport interface SymbolDeclaration {\n  /**\n   * The name of the symbol in table.\n   */\n  readonly name: string;\n\n  /**\n   * The kind of symbol to declare.\n   */\n  readonly kind: CompletionKind;\n\n  /**\n   * Type of the symbol. The type symbol should refer to a symbol for a type.\n   */\n  readonly type: Symbol;\n\n  /**\n   * The definion of the symbol if one exists.\n   */\n  readonly definition?: Definition;\n}\n\n/**\n * A section of hover text. If the text is code then langauge should be provided.\n * Otherwise the text is assumed to be Markdown text that will be sanitized.\n */\nexport interface HoverTextSection {\n  /**\n   * Source code or markdown text describing the symbol a the hover location.\n   */\n  readonly text: string;\n\n  /**\n   * The langauge of the source if `text` is a souce code fragment.\n   */\n  readonly language?: string;\n}\n\n/**\n * Hover infomration for a symbol at the hover location.\n */\nexport interface Hover {\n  /**\n   * The hover text to display for the symbol at the hover location. If the text includes\n   * source code, the section will specify which langauge it should be interpreted as.\n   */\n  readonly text: HoverTextSection[];\n\n  /**\n   * The span of source the hover covers.\n   */\n  readonly span: Span;\n}\n\n/**\n * An instance of an Angular language service created by `createLanguageService()`.\n *\n * The language service returns information about Angular templates that are included in a project\n * as\n * defined by the `LanguageServiceHost`.\n *\n * When a method expects a `fileName` this file can either be source file in the project that\n * contains\n * a template in a string literal or a template file referenced by the project returned by\n * `getTemplateReference()`. All other files will cause the method to return `undefined`.\n *\n * If a method takes a `position`, it is the offset of the UTF-16 code-point relative to the\n * beginning\n * of the file reference by `fileName`.\n *\n * This interface and all interfaces and types marked as `LanguageSerivce` types, describe  a\n * particlar\n * implementation of the Angular language service and is not intented to be implemented. Adding\n * members\n * to the interface will not be considered a breaking change as defined by SemVer.\n *\n * Removing a member or making a member optional, changing a method parameters, or changing a\n * member's\n * type will all be considered a breaking change.\n *\n * While an interface is marked as experimental breaking-changes will be allowed between minor\n * releases.\n * After an interface is marked as stable breaking-changes will only be allowed between major\n * releases.\n * No breaking changes are allowed between patch releases.\n *\n * @experimental\n */\nexport interface LanguageService {\n  /**\n   * Returns a list of all the external templates referenced by the project.\n   */\n  getTemplateReferences(): string[] /* | undefined */;\n\n  /**\n   * Returns a list of all error for all templates in the given file.\n   */\n  getDiagnostics(fileName: string): Diagnostics /* | undefined */;\n\n  /**\n   * Return the completions at the given position.\n   */\n  getCompletionsAt(fileName: string, position: number): Completions /* | undefined */;\n\n  /**\n   * Return the definition location for the symbol at position.\n   */\n  getDefinitionAt(fileName: string, position: number): Definition /* | undefined */;\n\n  /**\n   * Return the hover information for the symbol at position.\n   */\n  getHoverAt(fileName: string, position: number): Hover /* | undefined */;\n\n  /**\n   * Return the pipes that are available at the given position.\n   */\n  getPipesAt(fileName: string, position: number): Pipes /* | undefined */;\n}\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}