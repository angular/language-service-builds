{"version":3,"file":"reflector_host.js","sourceRoot":"","sources":["../../../../modules/@angular/language-service/src/reflector_host.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {StaticReflectorHost, StaticSymbol} from '@angular/compiler';\nimport {MetadataCollector} from '@angular/tsc-wrapped/src/collector';\nimport {ModuleMetadata} from '@angular/tsc-wrapped/src/schema';\nimport * as path from 'path';\nimport * as ts from 'typescript';\n\nconst EXT = /(\\.ts|\\.d\\.ts|\\.js|\\.jsx|\\.tsx)$/;\nconst DTS = /\\.d\\.ts$/;\n\nlet serialNumber = 0;\n\nclass ReflectorModuleModuleResolutionHost implements ts.ModuleResolutionHost {\n  private forceExists: string[] = [];\n\n  constructor(private host: ts.LanguageServiceHost) {\n    if (host.directoryExists)\n      this.directoryExists = directoryName => this.host.directoryExists(directoryName);\n  }\n\n  fileExists(fileName: string): boolean {\n    return !!this.host.getScriptSnapshot(fileName) || this.forceExists.indexOf(fileName) >= 0;\n  }\n\n  readFile(fileName: string): string {\n    let snapshot = this.host.getScriptSnapshot(fileName);\n    if (snapshot) {\n      return snapshot.getText(0, snapshot.getLength());\n    }\n  }\n\n  directoryExists: (directoryName: string) => boolean;\n\n  forceExist(fileName: string): void { this.forceExists.push(fileName); }\n}\n\nexport class ReflectorHost implements StaticReflectorHost {\n  private metadataCollector: MetadataCollector;\n  private moduleResolverHost: ReflectorModuleModuleResolutionHost;\n  private _typeChecker: ts.TypeChecker;\n  private metadataCache = new Map<string, MetadataCacheEntry>();\n\n  constructor(\n      private getProgram: () => ts.Program, private serviceHost: ts.LanguageServiceHost,\n      private options: ts.CompilerOptions, private basePath: string) {\n    this.moduleResolverHost = new ReflectorModuleModuleResolutionHost(serviceHost);\n    this.metadataCollector = new MetadataCollector();\n  }\n\n  getCanonicalFileName(fileName: string): string { return fileName; }\n\n  private get program() { return this.getProgram(); }\n\n  public moduleNameToFileName(moduleName: string, containingFile: string) {\n    if (!containingFile || !containingFile.length) {\n      if (moduleName.indexOf('.') === 0) {\n        throw new Error('Resolution of relative paths requires a containing file.');\n      }\n      // Any containing file gives the same result for absolute imports\n      containingFile = this.getCanonicalFileName(path.join(this.basePath, 'index.ts'));\n    }\n    moduleName = moduleName.replace(EXT, '');\n    const resolved =\n        ts.resolveModuleName(moduleName, containingFile, this.options, this.moduleResolverHost)\n            .resolvedModule;\n    return resolved ? resolved.resolvedFileName : null;\n  };\n\n  /**\n   * We want a moduleId that will appear in import statements in the generated code.\n   * These need to be in a form that system.js can load, so absolute file paths don't work.\n   * Relativize the paths by checking candidate prefixes of the absolute path, to see if\n   * they are resolvable by the moduleResolution strategy from the CompilerHost.\n   */\n  fileNameToModuleName(importedFile: string, containingFile: string) {\n    // TODO(tbosch): if a file does not yet exist (because we compile it later),\n    // we still need to create it so that the `resolve` method works!\n    if (!this.moduleResolverHost.fileExists(importedFile)) {\n      this.moduleResolverHost.forceExist(importedFile);\n    }\n\n    const parts = importedFile.replace(EXT, '').split(path.sep).filter(p => !!p);\n\n    for (let index = parts.length - 1; index >= 0; index--) {\n      let candidate = parts.slice(index, parts.length).join(path.sep);\n      if (this.moduleNameToFileName('.' + path.sep + candidate, containingFile) === importedFile) {\n        return `./${candidate}`;\n      }\n      if (this.moduleNameToFileName(candidate, containingFile) === importedFile) {\n        return candidate;\n      }\n    }\n    throw new Error(\n        `Unable to find any resolvable import for ${importedFile} relative to ${containingFile}`);\n  }\n\n  private get typeChecker(): ts.TypeChecker {\n    let result = this._typeChecker;\n    if (!result) {\n      result = this._typeChecker = this.program.getTypeChecker();\n    }\n    return result;\n  }\n\n  private typeCache = new Map<string, StaticSymbol>();\n\n  // TODO(alexeagle): take a statictype\n  getMetadataFor(filePath: string): ModuleMetadata[] {\n    if (!this.moduleResolverHost.fileExists(filePath)) {\n      throw new Error(`No such file '${filePath}'`);\n    }\n    if (DTS.test(filePath)) {\n      const metadataPath = filePath.replace(DTS, '.metadata.json');\n      if (this.moduleResolverHost.fileExists(metadataPath)) {\n        return this.readMetadata(metadataPath);\n      }\n    }\n\n    let sf = this.program.getSourceFile(filePath);\n    if (!sf) {\n      throw new Error(`Source file ${filePath} not present in program.`);\n    }\n\n    const entry = this.metadataCache.get(sf.path);\n    const version = this.serviceHost.getScriptVersion(sf.path);\n    if (entry && entry.version == version) {\n      if (!entry.content) return undefined;\n      return [entry.content];\n    }\n    const metadata = this.metadataCollector.getMetadata(sf);\n    this.metadataCache.set(sf.path, {version, content: metadata});\n    if (metadata) return [metadata];\n  }\n\n  readMetadata(filePath: string) {\n    try {\n      const text = this.moduleResolverHost.readFile(filePath);\n      const result = JSON.parse(text);\n      if (!Array.isArray(result)) return [result];\n      return result;\n    } catch (e) {\n      console.error(`Failed to read JSON file ${filePath}`);\n      throw e;\n    }\n  }\n}\n\ninterface MetadataCacheEntry {\n  version: string;\n  content: ModuleMetadata;\n}\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}