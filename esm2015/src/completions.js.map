{"version":3,"file":"completions.js","sourceRoot":"","sources":["../../../../packages/language-service/src/completions.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAEH,OAAO,EAAoH,WAAW,EAAgB,OAAO,EAAmC,gBAAgB,EAAE,cAAc,EAAiC,mBAAmB,EAAE,SAAS,EAAE,YAAY,EAAgB,eAAe,EAAE,cAAc,EAAmC,IAAI,EAAwB,QAAQ,EAAE,oBAAoB,EAAE,WAAW,EAAmB,MAAM,mBAAmB,CAAC;AACnf,OAAO,EAAyB,kBAAkB,EAAC,MAAM,6CAA6C,CAAC;AAGvG,OAAO,EAAC,wBAAwB,EAAC,MAAM,eAAe,CAAC;AACvD,OAAO,EAAC,cAAc,EAAE,YAAY,EAAE,UAAU,EAAE,aAAa,EAAC,MAAM,aAAa,CAAC;AAEpF,OAAO,EAAC,8BAA8B,EAAE,iBAAiB,EAAE,OAAO,EAAE,YAAY,EAAE,oBAAoB,EAAE,MAAM,EAAE,YAAY,EAAE,MAAM,EAAE,YAAY,EAAC,MAAM,SAAS,CAAC;AAEnK,MAAM,oBAAoB,GAAG,GAAG,CAAC;AAEjC,MAAM,kBAAkB,GAAG;IACzB,IAAI,EAAE,IAAI;IACV,MAAM,EAAE,IAAI;IACZ,QAAQ,EAAE,IAAI;IACd,IAAI,EAAE,IAAI;IACV,IAAI,EAAE,IAAI;IACV,KAAK,EAAE,IAAI;IACX,IAAI,EAAE,IAAI;IACV,IAAI,EAAE,IAAI;CACX,CAAC;AAEF,MAAM,iCAAiC,YAA0B;IAC/D,IAAI,MAAM,GAA0B,SAAS,CAAC;IAC9C,IAAI,EAAC,OAAO,EAAE,WAAW,EAAE,QAAQ,EAAC,GAAG,YAAY,CAAC;IACpD,6EAA6E;IAC7E,EAAE,CAAC,CAAC,YAAY,CAAC,QAAQ,IAAI,IAAI,CAAC,CAAC,CAAC;QAClC,IAAI,gBAAgB,GAAG,YAAY,CAAC,QAAQ,GAAG,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC;QACnE,IAAI,IAAI,GAAG,QAAQ,CAAC,OAAO,EAAE,gBAAgB,CAAC,CAAC;QAC/C,IAAI,YAAY,GAAG,IAAI,CAAC,IAAI,CAAC;QAC7B,EAAE,CAAC,CAAC,IAAI,CAAC,KAAK,IAAI,CAAC,YAAY,CAAC,CAAC,CAAC;YAChC,MAAM,GAAG,kBAAkB,CAAC,YAAY,EAAE,IAAI,CAAC,CAAC;QAClD,CAAC;QAAC,IAAI,CAAC,CAAC;YACN,IAAI,WAAW,GAAG,gBAAgB,GAAG,YAAY,CAAC,UAAU,CAAC,KAAK,CAAC,MAAM,CAAC;YAC1E,YAAY,CAAC,KAAK,CACd;gBACE,YAAY,CAAC,GAAG;oBACd,IAAI,YAAY,GAAG,MAAM,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC;oBAC1C,IAAI,MAAM,GAAG,GAAG,CAAC,IAAI,CAAC,MAAM,CAAC;oBAC7B,EAAE,CAAC,CAAC,gBAAgB;wBAChB,YAAY,CAAC,KAAK,GAAG,MAAM,GAAG,CAAC,CAAC,qCAAqC,CAAC,CAAC,CAAC;wBAC1E,4DAA4D;wBAC5D,MAAM,GAAG,kBAAkB,CAAC,YAAY,EAAE,IAAI,CAAC,CAAC;oBAClD,CAAC;oBAAC,IAAI,CAAC,EAAE,CAAC,CAAC,gBAAgB,GAAG,YAAY,CAAC,GAAG,CAAC,CAAC,CAAC;wBAC/C,4EAA4E;wBAC5E,oCAAoC;wBACpC,MAAM,GAAG,oBAAoB,CAAC,YAAY,EAAE,IAAI,CAAC,CAAC;oBACpD,CAAC;gBACH,CAAC;gBACD,cAAc,CAAC,GAAG;oBAChB,EAAE,CAAC,CAAC,CAAC,GAAG,CAAC,SAAS,IAAI,CAAC,MAAM,CAAC,gBAAgB,EAAE,MAAM,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC;wBACvE,kEAAkE;wBAClE,MAAM,GAAG,oBAAoB,CAAC,YAAY,EAAE,IAAI,CAAC,CAAC;oBACpD,CAAC;oBAAC,IAAI,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC,SAAS,IAAI,MAAM,CAAC,gBAAgB,EAAE,MAAM,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC;wBAC5E,MAAM,GAAG,yBAAyB,CAAC,YAAY,EAAE,gBAAgB,EAAE,GAAG,CAAC,CAAC;oBAC1E,CAAC;gBACH,CAAC;gBACD,SAAS,CAAC,GAAG;oBACX,+BAA+B;oBAC/B,MAAM,GAAG,iBAAiB,CAAC,aAAa,CAAC,QAAQ,EAAE,MAAM,CAAC,GAAG,CAAC,CAAC,EAAE,WAAW,CAAC,CAAC;oBAC9E,EAAE,CAAC,CAAC,MAAM,CAAC;wBAAC,MAAM,CAAC,MAAM,CAAC;oBAC1B,MAAM,GAAG,wBAAwB,CAAC,YAAY,EAAE,gBAAgB,CAAC,CAAC;oBAClE,EAAE,CAAC,CAAC,MAAM,CAAC;wBAAC,MAAM,CAAC,MAAM,CAAC;oBAC1B,IAAI,OAAO,GAAG,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC;oBAClC,EAAE,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC;wBACZ,IAAI,UAAU,GAAG,oBAAoB,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;wBACpD,EAAE,CAAC,CAAC,UAAU,CAAC,WAAW,KAAK,cAAc,CAAC,aAAa,CAAC,CAAC,CAAC;4BAC5D,MAAM,GAAG,+BAA+B,CAAC,YAAY,EAAE,IAAI,CAAC,CAAC;4BAC7D,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;gCACZ,4DAA4D;gCAC5D,MAAM,GAAG,kBAAkB,CAAC,YAAY,EAAE,IAAI,CAAC,CAAC;4BAClD,CAAC;wBACH,CAAC;oBACH,CAAC;oBAAC,IAAI,CAAC,CAAC;wBACN,mEAAmE;wBACnE,MAAM,GAAG,+BAA+B,CAAC,YAAY,EAAE,IAAI,CAAC,CAAC;wBAC7D,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;4BACZ,MAAM,GAAG,kBAAkB,CAAC,YAAY,EAAE,IAAI,CAAC,CAAC;wBAClD,CAAC;oBACH,CAAC;gBACH,CAAC;gBACD,YAAY,CAAC,GAAG,IAAG,CAAC;gBACpB,cAAc,CAAC,GAAG,IAAG,CAAC;gBACtB,kBAAkB,CAAC,GAAG,IAAG,CAAC;aAC3B,EACD,IAAI,CAAC,CAAC;QACZ,CAAC;IACH,CAAC;IACD,MAAM,CAAC,MAAM,CAAC;AAChB,CAAC;AAED,8BAA8B,IAAkB,EAAE,IAAsB;IACtE,IAAI,IAAI,GAAG,IAAI,CAAC,IAAI,YAAY,OAAO,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAC/E,EAAE,CAAC,CAAC,IAAI,YAAY,OAAO,CAAC,CAAC,CAAC;QAC5B,MAAM,CAAC,8BAA8B,CAAC,IAAI,EAAE,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;IAC/D,CAAC;IACD,MAAM,CAAC,SAAS,CAAC;AACnB,CAAC;AAED,wCACI,IAAkB,EAAE,WAAmB,EAAE,OAAiB;IAC5D,MAAM,UAAU,GAAG,2BAA2B,CAAC,IAAI,EAAE,WAAW,EAAE,OAAO,CAAC,CAAC;IAE3E,yCAAyC;IACzC,MAAM,CAAC,UAAU,CAAC,GAAG,CAAa,IAAI,CAAC,EAAE,CAAC,CAAC;QACP,IAAI,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,gBAAgB,CAAC,CAAC,CAAC,WAAW;QACpD,IAAI,EAAE,UAAU,CAAC,IAAI,CAAC;QACtB,IAAI,EAAE,IAAI,CAAC,IAAI;KAChB,CAAC,CAAC,CAAC;AACxC,CAAC;AAED,qCACI,IAAkB,EAAE,WAAmB,EAAE,OAAiB;IAC5D,IAAI,UAAU,GAAe,EAAE,CAAC;IAEhC,sBAAsB;IACtB,IAAI,cAAc,GAAG,cAAc,CAAC,WAAW,CAAC,IAAI,EAAE,CAAC;IACvD,EAAE,CAAC,CAAC,cAAc,CAAC,CAAC,CAAC;QACnB,UAAU,CAAC,IAAI,CAAC,GAAG,cAAc,CAAC,GAAG,CAAW,IAAI,CAAC,EAAE,CAAC,CAAC,EAAC,IAAI,EAAE,QAAQ,EAAE,IAAI,EAAC,CAAC,CAAC,CAAC,CAAC;IACrF,CAAC;IAED,sBAAsB;IACtB,IAAI,cAAc,GAAG,aAAa,CAAC,WAAW,CAAC,CAAC;IAChD,EAAE,CAAC,CAAC,cAAc,CAAC,CAAC,CAAC;QACnB,UAAU,CAAC,IAAI,CAAC,GAAG,cAAc,CAAC,GAAG,CAAW,IAAI,CAAC,EAAE,CAAC,CAAC,EAAC,IAAI,EAAE,KAAK,EAAE,IAAI,EAAC,CAAC,CAAC,CAAC,CAAC;IAClF,CAAC;IAED,kBAAkB;IAClB,IAAI,UAAU,GAAG,UAAU,CAAC,WAAW,CAAC,CAAC;IACzC,EAAE,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC;QACf,UAAU,CAAC,IAAI,CAAC,GAAG,UAAU,CAAC,GAAG,CAAW,IAAI,CAAC,EAAE,CAAC,CAAC,EAAC,IAAI,EAAE,MAAM,EAAE,IAAI,EAAC,CAAC,CAAC,CAAC,CAAC;IAC/E,CAAC;IAED,IAAI,EAAC,SAAS,EAAE,GAAG,EAAE,WAAW,EAAC,GAAG,YAAY,CAAC,IAAI,CAAC,CAAC;IACvD,EAAE,CAAC,CAAC,SAAS,IAAI,SAAS,CAAC,MAAM,CAAC,CAAC,CAAC;QAClC,0DAA0D;QAC1D,MAAM,mBAAmB,GACrB,SAAS,CAAC,MAAM,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC,QAAQ,CAAC,OAAO,IAAI,QAAQ,CAAC,OAAO,IAAI,WAAW,CAAC,CAAC;QACvF,MAAM,yBAAyB,GAC3B,mBAAmB,CAAC,GAAG,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC,EAAC,QAAQ,EAAE,KAAK,EAAE,QAAQ,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,EAAC,CAAC,CAAC,CAAC;QAC9F,IAAI,KAAK,GAAG,OAAO,CAAC,yBAAyB,CAAC,GAAG,CAAa,eAAe,CAAC,EAAE;YAC9E,MAAM,SAAS,GAAG,WAAW,CAAC,GAAG,CAAC,eAAe,CAAC,QAAQ,CAAG,CAAC;YAC9D,MAAM,MAAM,GAAG,eAAe,CAAC,KAAK,CAAC,GAAG,CACpC,IAAI,CAAC,EAAE,CAAC,CAAC,EAAC,IAAI,EAAE,KAAK,EAAE,IAAI,IAAI,SAAS,CAAC,MAAM,EAAE,MAAM,EAAE,IAAI,IAAI,SAAS,CAAC,OAAO,EAAC,CAAC,CAAC,CAAC;YAC1F,MAAM,CAAC,MAAM,CAAC;QAChB,CAAC,CAAC,CAAC,CAAC;QAEJ,sEAAsE;QACtE,yBAAyB,CAAC,OAAO,CAAC,eAAe,CAAC,EAAE;YAClD,MAAM,QAAQ,GAAG,eAAe,CAAC,QAAQ,CAAC;YAC1C,MAAM,SAAS,GAAG,WAAW,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;YAC5C,EAAE,CAAC,CAAC,SAAS,IAAI,oBAAoB,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI,QAAQ,CAAC,KAAK,CAAC,MAAM;gBAC1E,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;gBACtB,KAAK,CAAC,IAAI,CAAC,EAAC,IAAI,EAAE,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,QAAQ,EAAE,IAAI,EAAC,CAAC,CAAC;YACxD,CAAC;QACH,CAAC,CAAC,CAAC;QAEH,8EAA8E;QAC9E,IAAI,eAAe,GAAG,OAAO,CAAC,CAAC;YAC3B,wBAAwB,CAAC,OAAO,CAAC,CAAC,CAAC;YACnC,wBAAwB,CAAC,IAAI,OAAO,CAAC,WAAW,EAAE,EAAE,EAAE,EAAE,EAAE,IAAM,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC,CAAC;QAEnF,IAAI,OAAO,GAAG,IAAI,eAAe,EAAE,CAAC;QACpC,OAAO,CAAC,cAAc,CAAC,SAAS,CAAC,CAAC;QAClC,OAAO,CAAC,KAAK,CAAC,eAAe,EAAE,QAAQ,CAAC,EAAE;YACxC,IAAI,SAAS,GAAG,WAAW,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;YAC1C,EAAE,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC;gBACd,KAAK,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,EAAC,IAAI,EAAE,KAAK,EAAE,IAAI,EAAC,CAAC,CAAC,CAAC,CAAC;gBAChF,KAAK,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,EAAC,IAAI,EAAE,MAAM,EAAE,IAAI,EAAC,CAAC,CAAC,CAAC,CAAC;YACpF,CAAC;QACH,CAAC,CAAC,CAAC;QAEH,yDAAyD;QACzD,KAAK,GAAG,SAAS,CAAC,KAAK,CAAC,CAAC;QAEzB,qFAAqF;QACrF,UAAU;QACV,UAAU,CAAC,IAAI,CAAC,GAAG,OAAO,CAAC,KAAK,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC;IACvD,CAAC;IACD,MAAM,CAAC,UAAU,CAAC;AACpB,CAAC;AAED,mCACI,IAAkB,EAAE,QAAgB,EAAE,IAAe;IACvD,MAAM,IAAI,GAAG,iBAAiB,CAAC,IAAI,CAAC,WAAW,EAAE,QAAQ,CAAC,CAAC;IAC3D,MAAM,YAAY,GAAG,IAAI,CAAC,IAAI,CAAC;IAC/B,MAAM,KAAK,GAAG,8BAA8B,CAAC,IAAI,CAAC,CAAC;IACnD,EAAE,CAAC,CAAC,YAAY,CAAC,CAAC,CAAC;QACjB,MAAM,OAAO,GACT,IAAI,iBAAiB,CAAC,IAAI,EAAE,QAAQ,EAAE,IAAI,EAAE,GAAG,EAAE,CAAC,kBAAkB,CAAC,KAAK,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC,CAAC;QAC9F,YAAY,CAAC,KAAK,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;QAClC,EAAE,CAAC,CAAC,CAAC,OAAO,CAAC,MAAM,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC;YAC9C,iCAAiC;YACjC,MAAM,SAAS,GAAG,iBAAiB,CAAC,IAAI,CAAC,WAAW,EAAE,QAAQ,EAAE,mBAAmB,CAAC,IAAI,CAAC,CAAC;YAC1F,EAAE,CAAC,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC,CAAC;gBACnB,MAAM,YAAY,GAAG,IAAI,iBAAiB,CACtC,IAAI,EAAE,QAAQ,EAAE,IAAI,EAAE,GAAG,EAAE,CAAC,kBAAkB,CAAC,KAAK,EAAE,SAAS,EAAE,KAAK,CAAC,CAAC,CAAC;gBAC7E,SAAS,CAAC,IAAI,CAAC,KAAK,CAAC,YAAY,EAAE,IAAI,CAAC,CAAC;gBACzC,MAAM,CAAC,YAAY,CAAC,MAAM,CAAC;YAC7B,CAAC;QACH,CAAC;QACD,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC;IACxB,CAAC;AACH,CAAC;AAED,4BAA4B,IAAkB,EAAE,IAAsB;IACpE,IAAI,SAAS,GAAG,YAAY,EAAE,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC,IAAI,IAAI,kBAAkB,CAAC,CAAC,CAAC;IAE7E,mDAAmD;IACnD,IAAI,iBAAiB,GAAG,YAAY,CAAC,IAAI,CAAC;SACb,SAAS,CAAC,GAAG,CAAC,QAAQ,CAAC,EAAE,CAAC,QAAQ,CAAC,OAAO,CAAC;SAC3C,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC,IAAI,CAAa,CAAC;IAEhE,IAAI,UAAU,GACV,iBAAiB,CAAC,GAAG,CAAa,IAAI,CAAC,EAAE,CAAC,CAAC,EAAC,IAAI,EAAE,WAAW,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAC,CAAC,CAAC,CAAC;IACvF,IAAI,YAAY,GAAG,SAAS,CAAC,GAAG,CAAa,IAAI,CAAC,EAAE,CAAC,CAAC,EAAC,IAAI,EAAE,SAAS,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAC,CAAC,CAAC,CAAC;IAElG,sCAAsC;IACtC,MAAM,CAAC,YAAY,CAAC,YAAY,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC,CAAC;AACvD,CAAC;AAED,2BAA2B,KAAa,EAAE,QAAgB;IACxD,8BAA8B;IAC9B,MAAM,EAAE,GAAG,qBAAqB,CAAC;IACjC,IAAI,KAA2B,CAAC;IAChC,IAAI,MAAM,GAA0B,SAAS,CAAC;IAC9C,OAAO,KAAK,GAAG,EAAE,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC;QAC9B,IAAI,GAAG,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC;QAC1B,EAAE,CAAC,CAAC,QAAQ,IAAI,KAAK,CAAC,KAAK,IAAI,QAAQ,GAAG,CAAC,KAAK,CAAC,KAAK,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC;YAC9D,MAAM,GAAG,MAAM,CAAC,IAAI,CAAC,cAAc,CAAC;iBACtB,GAAG,CAAa,IAAI,CAAC,EAAE,CAAC,CAAC,EAAC,IAAI,EAAE,QAAQ,EAAE,IAAI,EAAE,IAAI,IAAI,GAAG,EAAE,IAAI,EAAE,IAAI,EAAC,CAAC,CAAC,CAAC;YACzF,KAAK,CAAC;QACR,CAAC;IACH,CAAC;IACD,MAAM,CAAC,MAAM,CAAC;AAChB,CAAC;AAED,kCAAkC,IAAkB,EAAE,QAAgB;IACpE,gDAAgD;IAChD,MAAM,YAAY,GAAG,iBAAiB,CAAC,IAAI,CAAC,WAAW,EAAE,QAAQ,CAAC,CAAC;IACnE,MAAM,YAAY,GAAG,YAAY,CAAC,IAAI,CAAC;IACvC,EAAE,CAAC,CAAC,YAAY,CAAC,CAAC,CAAC;QACjB,IAAI,OAAO,GAAG,IAAI,iBAAiB,CAC/B,IAAI,EAAE,QAAQ,EAAE,SAAS,EACzB,GAAG,EAAE,CAAC,kBAAkB,CAAC,8BAA8B,CAAC,IAAI,CAAC,EAAE,YAAY,EAAE,KAAK,CAAC,CAAC,CAAC;QACzF,YAAY,CAAC,KAAK,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;QAClC,MAAM,CAAC,YAAY,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;IACtC,CAAC;AACH,CAAC;AAED,wFAAwF;AACxF,oFAAoF;AACpF,wFAAwF;AACxF,0FAA0F;AAC1F,2FAA2F;AAC3F,gBAAgB;AAChB,yCAAyC,IAAkB,EAAE,IAAsB;IAEjF,IAAI,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;IACrB,EAAE,CAAC,CAAC,IAAI,YAAY,IAAI,CAAC,CAAC,CAAC;QACzB,IAAI,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,mCAAmC,CAAC,CAAC;QAClE,yFAAyF;QACzF,sFAAsF;QACtF,EAAE,CAAC,CAAC,KAAK;YACL,IAAI,CAAC,QAAQ,IAAI,CAAC,KAAK,CAAC,KAAK,IAAI,CAAC,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,MAAM,GAAG,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC;YACzF,MAAM,CAAC,8BAA8B,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;QACxD,CAAC;IACH,CAAC;AACH,CAAC;AAED,uBAAwB,SAAQ,mBAAmB;IAIjD,YACY,IAAkB,EAAU,QAAgB,EAAU,IAAgB,EAC9E,kBAAsC;QACxC,KAAK,EAAE,CAAC;QAFE,SAAI,GAAJ,IAAI,CAAc;QAAU,aAAQ,GAAR,QAAQ,CAAQ;QAAU,SAAI,GAAJ,IAAI,CAAY;QAGhF,IAAI,CAAC,kBAAkB,GAAG,kBAAkB,IAAI,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC;IAChF,CAAC;IAED,sBAAsB,CAAC,GAA8B;QACnD,IAAI,CAAC,yBAAyB,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;IAC5C,CAAC;IAED,oBAAoB,CAAC,GAA4B;QAC/C,IAAI,CAAC,yBAAyB,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;IAC5C,CAAC;IAED,UAAU,CAAC,GAAkB,IAAU,IAAI,CAAC,yBAAyB,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;IAErF,YAAY,CAAC,GAAe;QAC1B,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,IAAI,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,oBAAoB,CAAC,CAAC,CAAC,CAAC;YAC5F,sFAAsF;YACtF,6BAA6B;YAC7B,eAAe;YAEf,MAAM,GAAG,GAAG,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,oBAAoB,CAAC,MAAM,CAAC,CAAC;YAE/D,oBAAoB;YACpB,MAAM,YAAY,GAAG,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;YAC7C,MAAM,SAAS,GAAG,YAAY,CAAC,SAAS,CAAC;YACzC,MAAM,QAAQ,GACV,SAAS,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,IAAI,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,IAAI,IAAI,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;YAEnF,MAAM,qBAAqB,GACvB,IAAI,CAAC,IAAI,CAAC,gBAAgB,CAAC,qBAAqB,CAAC,GAAG,EAAE,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;YAEjF,uDAAuD;YACvD,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC;gBAAC,MAAM,CAAC;YACjC,MAAM,qBAAqB,GAAG,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC;YACnF,MAAM,QAAQ,GAAG,qBAAqB,CAAC,gBAAgB,CAAC;YACxD,MAAM,OAAO,GACT,QAAQ,CAAC,IAAI,CACT,OAAO,CAAC,EAAE,CAAC,MAAM,CAAC,qBAAqB,EAAE,OAAO,CAAC,IAAI,EAAE,eAAe,CAAC,IAAI,CAAC,CAAC;gBACjF,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,EAAE,CAAC,MAAM,CAAC,qBAAqB,EAAE,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC;YAE1E,MAAM,cAAc,GAAG,GAAG,EAAE;gBAC1B,IAAI,IAAI,GAAa,EAAE,CAAC;gBACxB,EAAE,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC;oBACb,MAAM,SAAS,GAAG,QAAQ,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC;oBAC9D,IAAI,GAAG,SAAS,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,IAAI,IAAI,IAAI,GAAG,CAAC;yBACxD,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,SAAS,CAAC,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;gBAC9D,CAAC;gBACD,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;gBACjB,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC,CAAY,EAAC,IAAI,EAAE,KAAK,EAAE,IAAI,EAAE,GAAG,EAAE,IAAI,EAAE,GAAG,EAAC,CAAA,CAAC,CAAC;YACjF,CAAC,CAAC;YAEF,EAAE,CAAC,CAAC,CAAC,OAAO,IAAI,CAAC,OAAO,CAAC,GAAG,IAAI,GAAG,IAAI,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;gBAC5D,mFAAmF;gBACnF,YAAY;gBACZ,cAAc,EAAE,CAAC;YACnB,CAAC;YAAC,IAAI,CAAC,EAAE,CAAC,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC,CAAC;gBAC5B,MAAM,aAAa,GAAG,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;gBACnD,IAAI,CAAC,MAAM,GAAG,EAAE,CAAC;gBACjB,EAAE,CAAC,CAAC,aAAa,IAAI,CAAC,IAAI,qBAAqB,IAAI,aAAa,CAAC,CAAC,CAAC;oBACjE,qFAAqF;oBACrF,uCAAuC;oBACvC,MAAM,iBAAiB,GAAG,YAAY,CAAC,GAAG,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;oBACzD,EAAE,CAAC,CAAC,iBAAiB,CAAC,CAAC,CAAC;wBACtB,MAAM,YAAY,GACd,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,kBAAkB,CAAC,iBAAiB,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;wBAClF,EAAE,CAAC,CAAC,YAAY,CAAC,CAAC,CAAC;4BACjB,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,oBAAoB,CAAC,YAAY,CAAC,MAAM,EAAE,CAAC,CAAC;wBACjE,CAAC;oBACH,CAAC;gBACH,CAAC;gBAAC,IAAI,CAAC,EAAE,CAAC,CAAC,OAAO,CAAC,GAAG,IAAI,qBAAqB,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM,GAAG,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;oBACrF,cAAc,EAAE,CAAC;gBACnB,CAAC;YACH,CAAC;YAAC,IAAI,CAAC,CAAC;gBACN,uFAAuF;gBACvF,yBAAyB;gBACzB,EAAE,CAAC,CAAC,CAAC,OAAO,CAAC,UAAU,IAAI,MAAM,CAAC,qBAAqB,EAAE,OAAO,CAAC,UAAU,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;oBAClF,CAAC,OAAO,CAAC,GAAG;wBACX,qBAAqB,GAAG,OAAO,CAAC,IAAI,CAAC,KAAK,GAAG,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM,GAAG,GAAG,CAAC,MAAM,CAAC,CAAC;oBAChF,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC;oBACjB,MAAM,IAAI,GAAG,IAAI,SAAS,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;oBACtD,IAAI,CAAC,yBAAyB,CAC1B,OAAO,CAAC,UAAU,CAAC,CAAC,CAAC,OAAO,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC;wBACxB,IAAI,YAAY,CAAC,IAAI,EAAE,IAAI,gBAAgB,CAAC,IAAI,CAAC,EAAE,EAAE,CAAC,EAC3E,qBAAqB,CAAC,CAAC;gBAC7B,CAAC;gBAAC,IAAI,CAAC,CAAC;oBACN,cAAc,EAAE,CAAC;gBACnB,CAAC;YACH,CAAC;QACH,CAAC;IACH,CAAC;IAED,cAAc,CAAC,GAAiB;QAC9B,MAAM,kBAAkB,GAAG,IAAI,CAAC,QAAQ,GAAG,GAAG,CAAC,UAAU,CAAC,KAAK,CAAC,MAAM,CAAC;QACvE,EAAE,CAAC,CAAC,MAAM,CAAC,kBAAkB,EAAE,GAAG,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;YAC/C,MAAM,WAAW,GAAG,wBAAwB,CACxC,IAAI,CAAC,kBAAkB,EAAE,EAAE,GAAG,CAAC,KAAK,EAAE,kBAAkB,EAAE,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;YACxF,EAAE,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC;gBAChB,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,oBAAoB,CAAC,WAAW,CAAC,CAAC;YACvD,CAAC;QACH,CAAC;IACH,CAAC;IAEO,yBAAyB,CAAC,KAAU,EAAE,QAAiB;QAC7D,MAAM,OAAO,GAAG,wBAAwB,CACpC,IAAI,CAAC,kBAAkB,EAAE,EAAE,KAAK,EAAE,QAAQ,IAAI,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,sBAAsB,CAAC,CAAC,CAAC,QAAQ,EAC3F,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;QAC9B,EAAE,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC;YACZ,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,oBAAoB,CAAC,OAAO,CAAC,CAAC;QACnD,CAAC;IACH,CAAC;IAEO,oBAAoB,CAAC,OAAiB;QAC5C,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,MAAM,CAAC;aAC3D,GAAG,CAAC,MAAM,CAAC,EAAE,CAAC,CAAY,EAAC,IAAI,EAAE,MAAM,CAAC,IAAI,EAAE,IAAI,EAAE,MAAM,CAAC,IAAI,EAAE,IAAI,EAAE,MAAM,CAAC,IAAI,EAAC,CAAA,CAAC,CAAC;IAC5F,CAAC;IAED,IAAY,sBAAsB;QAChC,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;YACrC,MAAM,CAAC,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC;QAC9D,CAAC;QACD,MAAM,CAAC,CAAC,CAAC;IACX,CAAC;CACF;AAED,uBAAuB,QAAwB,EAAE,IAAU;IACzD,MAAM,CAAC,QAAQ,CAAC,MAAM,CAAC,SAAS,CAAC,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC;AACzD,CAAC;AAED,oBAAoB,IAAc;IAChC,IAAI,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;IACrB,EAAE,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC;QAChB,IAAI,GAAG,YAAY,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;QACpC,IAAI,GAAG,YAAY,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC;IACvC,CAAC;IACD,IAAI,MAAM,GAAG,CAAC,IAAI,CAAC,CAAC;IACpB,EAAE,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;QACf,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;QACpB,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;IACnB,CAAC;IACD,EAAE,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC;QAChB,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;QACpB,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;IACnB,CAAC;IACD,EAAE,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC;QAClB,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;IACtB,CAAC;IACD,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;AACzB,CAAC;AAED,MAAM,YAAY,GAAG,yBAAyB,CAAC;AAC/C,kCAAkC,OAAgB;IAChD,MAAM,WAAW,GAAG,IAAI,WAAW,EAAE,CAAC;IACtC,IAAI,UAAU,GAAG,WAAW,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;IAE9C,WAAW,CAAC,UAAU,CAAC,UAAU,CAAC,CAAC;IAEnC,GAAG,CAAC,CAAC,IAAI,IAAI,IAAI,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC;QAC/B,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC;YACnC,IAAI,CAAC,CAAC,EAAE,YAAY,CAAC,GAAG,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;YAC/C,WAAW,CAAC,YAAY,CAAC,YAAY,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC;YACnD,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE,IAAI,OAAO,CAAC,CAAC,CAAC;gBACvC,MAAM,OAAO,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;gBACxC,OAAO,CAAC,OAAO,CAAC,SAAS,CAAC,EAAE,CAAC,WAAW,CAAC,YAAY,CAAC,SAAS,CAAC,CAAC,CAAC;YACpE,CAAC;QACH,CAAC;IACH,CAAC;IACD,MAAM,CAAC,WAAW,CAAC;AACrB,CAAC;AAED,mBAAmB,KAAiB;IAClC,IAAI,WAAW,GAAG,IAAI,GAAG,EAAoB,CAAC;IAC9C,IAAI,SAAS,GAAG,IAAI,GAAG,EAAoB,CAAC;IAC5C,IAAI,MAAM,GAAe,EAAE,CAAC;IAC5B,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE;QACnB,EAAE,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC;YAClB,MAAM,CAAC,IAAI,CAAC;QACd,CAAC;QACD,EAAE,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC;YAClB,IAAI,SAAS,GAAG,SAAS,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;YACzC,EAAE,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC;gBACf,MAAM,CAAC,IAAI,CAAC,EAAC,IAAI,EAAE,IAAI,CAAC,IAAI,EAAE,QAAQ,EAAE,IAAI,EAAC,CAAC,CAAC;gBAC/C,SAAS,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;YACjC,CAAC;QACH,CAAC;QACD,EAAE,CAAC,CAAC,IAAI,CAAC,KAAK,IAAI,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC;YAC9B,IAAI,SAAS,GAAG,WAAW,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;YAC3C,EAAE,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC;gBACd,SAAS,CAAC,KAAK,GAAG,SAAS,CAAC,KAAK,IAAI,IAAI,CAAC,KAAK,CAAC;gBAChD,SAAS,CAAC,MAAM,GAAG,SAAS,CAAC,MAAM,IAAI,IAAI,CAAC,MAAM,CAAC;YACrD,CAAC;YAAC,IAAI,CAAC,CAAC;gBACN,IAAI,SAAS,GAAa,EAAC,IAAI,EAAE,IAAI,CAAC,IAAI,EAAC,CAAC;gBAC5C,EAAE,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC;oBAAC,SAAS,CAAC,KAAK,GAAG,IAAI,CAAC;gBACvC,EAAE,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC;oBAAC,SAAS,CAAC,MAAM,GAAG,IAAI,CAAC;gBACzC,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;gBACvB,WAAW,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC;YACxC,CAAC;QACH,CAAC;IACH,CAAC,CAAC,CAAC;IACH,MAAM,CAAC,MAAM,CAAC;AAChB,CAAC;AAED,sBAAsB,IAAc;IAClC,EAAE,CAAC,CAAC,IAAI,CAAC,KAAK,IAAI,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC;QAC9B,MAAM,CAAC;YACL,IAAI,EAAE,EAAC,IAAI,EAAE,IAAI,CAAC,IAAI,EAAE,KAAK,EAAE,IAAI,EAAE,MAAM,EAAE,KAAK,EAAC;YACnD,EAAC,IAAI,EAAE,IAAI,CAAC,IAAI,EAAE,KAAK,EAAE,KAAK,EAAE,MAAM,EAAE,IAAI,EAAC;SAC9C,CAAC;IACJ,CAAC;IACD,MAAM,CAAC,CAAC,IAAI,CAAC,CAAC;AAChB,CAAC;AAED,mBAAmB,IAAY;IAC7B,MAAM,CAAC,IAAI,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,WAAW,EAAE,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;AAC1D,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AST, AstPath, AttrAst, Attribute, BoundDirectivePropertyAst, BoundElementPropertyAst, BoundEventAst, BoundTextAst, CssSelector, DirectiveAst, Element, ElementAst, EmbeddedTemplateAst, ImplicitReceiver, NAMED_ENTITIES, NgContentAst, Node as HtmlAst, NullTemplateVisitor, ParseSpan, PropertyRead, ReferenceAst, SelectorMatcher, TagContentType, TemplateAst, TemplateAstVisitor, Text, TextAst, VariableAst, findNode, getHtmlTagDefinition, splitNsName, templateVisitAll} from '@angular/compiler';\nimport {DiagnosticTemplateInfo, getExpressionScope} from '@angular/compiler-cli/src/language_services';\n\nimport {AstResult, AttrInfo, SelectorInfo, TemplateInfo} from './common';\nimport {getExpressionCompletions} from './expressions';\nimport {attributeNames, elementNames, eventNames, propertyNames} from './html_info';\nimport {BuiltinType, Completion, Completions, Span, Symbol, SymbolDeclaration, SymbolTable, TemplateSource} from './types';\nimport {diagnosticInfoFromTemplateInfo, findTemplateAstAt, flatten, getSelectors, hasTemplateReference, inSpan, removeSuffix, spanOf, uniqueByName} from './utils';\n\nconst TEMPLATE_ATTR_PREFIX = '*';\n\nconst hiddenHtmlElements = {\n  html: true,\n  script: true,\n  noscript: true,\n  base: true,\n  body: true,\n  title: true,\n  head: true,\n  link: true,\n};\n\nexport function getTemplateCompletions(templateInfo: TemplateInfo): Completions|undefined {\n  let result: Completions|undefined = undefined;\n  let {htmlAst, templateAst, template} = templateInfo;\n  // The templateNode starts at the delimiter character so we add 1 to skip it.\n  if (templateInfo.position != null) {\n    let templatePosition = templateInfo.position - template.span.start;\n    let path = findNode(htmlAst, templatePosition);\n    let mostSpecific = path.tail;\n    if (path.empty || !mostSpecific) {\n      result = elementCompletions(templateInfo, path);\n    } else {\n      let astPosition = templatePosition - mostSpecific.sourceSpan.start.offset;\n      mostSpecific.visit(\n          {\n            visitElement(ast) {\n              let startTagSpan = spanOf(ast.sourceSpan);\n              let tagLen = ast.name.length;\n              if (templatePosition <=\n                  startTagSpan.start + tagLen + 1 /* 1 for the opening angle bracked */) {\n                // If we are in the tag then return the element completions.\n                result = elementCompletions(templateInfo, path);\n              } else if (templatePosition < startTagSpan.end) {\n                // We are in the attribute section of the element (but not in an attribute).\n                // Return the attribute completions.\n                result = attributeCompletions(templateInfo, path);\n              }\n            },\n            visitAttribute(ast) {\n              if (!ast.valueSpan || !inSpan(templatePosition, spanOf(ast.valueSpan))) {\n                // We are in the name of an attribute. Show attribute completions.\n                result = attributeCompletions(templateInfo, path);\n              } else if (ast.valueSpan && inSpan(templatePosition, spanOf(ast.valueSpan))) {\n                result = attributeValueCompletions(templateInfo, templatePosition, ast);\n              }\n            },\n            visitText(ast) {\n              // Check if we are in a entity.\n              result = entityCompletions(getSourceText(template, spanOf(ast)), astPosition);\n              if (result) return result;\n              result = interpolationCompletions(templateInfo, templatePosition);\n              if (result) return result;\n              let element = path.first(Element);\n              if (element) {\n                let definition = getHtmlTagDefinition(element.name);\n                if (definition.contentType === TagContentType.PARSABLE_DATA) {\n                  result = voidElementAttributeCompletions(templateInfo, path);\n                  if (!result) {\n                    // If the element can hold content Show element completions.\n                    result = elementCompletions(templateInfo, path);\n                  }\n                }\n              } else {\n                // If no element container, implies parsable data so show elements.\n                result = voidElementAttributeCompletions(templateInfo, path);\n                if (!result) {\n                  result = elementCompletions(templateInfo, path);\n                }\n              }\n            },\n            visitComment(ast) {},\n            visitExpansion(ast) {},\n            visitExpansionCase(ast) {}\n          },\n          null);\n    }\n  }\n  return result;\n}\n\nfunction attributeCompletions(info: TemplateInfo, path: AstPath<HtmlAst>): Completions|undefined {\n  let item = path.tail instanceof Element ? path.tail : path.parentOf(path.tail);\n  if (item instanceof Element) {\n    return attributeCompletionsForElement(info, item.name, item);\n  }\n  return undefined;\n}\n\nfunction attributeCompletionsForElement(\n    info: TemplateInfo, elementName: string, element?: Element): Completions {\n  const attributes = getAttributeInfosForElement(info, elementName, element);\n\n  // Map all the attributes to a completion\n  return attributes.map<Completion>(attr => ({\n                                      kind: attr.fromHtml ? 'html attribute' : 'attribute',\n                                      name: nameOfAttr(attr),\n                                      sort: attr.name\n                                    }));\n}\n\nfunction getAttributeInfosForElement(\n    info: TemplateInfo, elementName: string, element?: Element): AttrInfo[] {\n  let attributes: AttrInfo[] = [];\n\n  // Add html attributes\n  let htmlAttributes = attributeNames(elementName) || [];\n  if (htmlAttributes) {\n    attributes.push(...htmlAttributes.map<AttrInfo>(name => ({name, fromHtml: true})));\n  }\n\n  // Add html properties\n  let htmlProperties = propertyNames(elementName);\n  if (htmlProperties) {\n    attributes.push(...htmlProperties.map<AttrInfo>(name => ({name, input: true})));\n  }\n\n  // Add html events\n  let htmlEvents = eventNames(elementName);\n  if (htmlEvents) {\n    attributes.push(...htmlEvents.map<AttrInfo>(name => ({name, output: true})));\n  }\n\n  let {selectors, map: selectorMap} = getSelectors(info);\n  if (selectors && selectors.length) {\n    // All the attributes that are selectable should be shown.\n    const applicableSelectors =\n        selectors.filter(selector => !selector.element || selector.element == elementName);\n    const selectorAndAttributeNames =\n        applicableSelectors.map(selector => ({selector, attrs: selector.attrs.filter(a => !!a)}));\n    let attrs = flatten(selectorAndAttributeNames.map<AttrInfo[]>(selectorAndAttr => {\n      const directive = selectorMap.get(selectorAndAttr.selector) !;\n      const result = selectorAndAttr.attrs.map<AttrInfo>(\n          name => ({name, input: name in directive.inputs, output: name in directive.outputs}));\n      return result;\n    }));\n\n    // Add template attribute if a directive contains a template reference\n    selectorAndAttributeNames.forEach(selectorAndAttr => {\n      const selector = selectorAndAttr.selector;\n      const directive = selectorMap.get(selector);\n      if (directive && hasTemplateReference(directive.type) && selector.attrs.length &&\n          selector.attrs[0]) {\n        attrs.push({name: selector.attrs[0], template: true});\n      }\n    });\n\n    // All input and output properties of the matching directives should be added.\n    let elementSelector = element ?\n        createElementCssSelector(element) :\n        createElementCssSelector(new Element(elementName, [], [], null !, null, null));\n\n    let matcher = new SelectorMatcher();\n    matcher.addSelectables(selectors);\n    matcher.match(elementSelector, selector => {\n      let directive = selectorMap.get(selector);\n      if (directive) {\n        attrs.push(...Object.keys(directive.inputs).map(name => ({name, input: true})));\n        attrs.push(...Object.keys(directive.outputs).map(name => ({name, output: true})));\n      }\n    });\n\n    // If a name shows up twice, fold it into a single value.\n    attrs = foldAttrs(attrs);\n\n    // Now expand them back out to ensure that input/output shows up as well as input and\n    // output.\n    attributes.push(...flatten(attrs.map(expandedAttr)));\n  }\n  return attributes;\n}\n\nfunction attributeValueCompletions(\n    info: TemplateInfo, position: number, attr: Attribute): Completions|undefined {\n  const path = findTemplateAstAt(info.templateAst, position);\n  const mostSpecific = path.tail;\n  const dinfo = diagnosticInfoFromTemplateInfo(info);\n  if (mostSpecific) {\n    const visitor =\n        new ExpressionVisitor(info, position, attr, () => getExpressionScope(dinfo, path, false));\n    mostSpecific.visit(visitor, null);\n    if (!visitor.result || !visitor.result.length) {\n      // Try allwoing widening the path\n      const widerPath = findTemplateAstAt(info.templateAst, position, /* allowWidening */ true);\n      if (widerPath.tail) {\n        const widerVisitor = new ExpressionVisitor(\n            info, position, attr, () => getExpressionScope(dinfo, widerPath, false));\n        widerPath.tail.visit(widerVisitor, null);\n        return widerVisitor.result;\n      }\n    }\n    return visitor.result;\n  }\n}\n\nfunction elementCompletions(info: TemplateInfo, path: AstPath<HtmlAst>): Completions|undefined {\n  let htmlNames = elementNames().filter(name => !(name in hiddenHtmlElements));\n\n  // Collect the elements referenced by the selectors\n  let directiveElements = getSelectors(info)\n                              .selectors.map(selector => selector.element)\n                              .filter(name => !!name) as string[];\n\n  let components =\n      directiveElements.map<Completion>(name => ({kind: 'component', name, sort: name}));\n  let htmlElements = htmlNames.map<Completion>(name => ({kind: 'element', name: name, sort: name}));\n\n  // Return components and html elements\n  return uniqueByName(htmlElements.concat(components));\n}\n\nfunction entityCompletions(value: string, position: number): Completions|undefined {\n  // Look for entity completions\n  const re = /&[A-Za-z]*;?(?!\\d)/g;\n  let found: RegExpExecArray|null;\n  let result: Completions|undefined = undefined;\n  while (found = re.exec(value)) {\n    let len = found[0].length;\n    if (position >= found.index && position < (found.index + len)) {\n      result = Object.keys(NAMED_ENTITIES)\n                   .map<Completion>(name => ({kind: 'entity', name: `&${name};`, sort: name}));\n      break;\n    }\n  }\n  return result;\n}\n\nfunction interpolationCompletions(info: TemplateInfo, position: number): Completions|undefined {\n  // Look for an interpolation in at the position.\n  const templatePath = findTemplateAstAt(info.templateAst, position);\n  const mostSpecific = templatePath.tail;\n  if (mostSpecific) {\n    let visitor = new ExpressionVisitor(\n        info, position, undefined,\n        () => getExpressionScope(diagnosticInfoFromTemplateInfo(info), templatePath, false));\n    mostSpecific.visit(visitor, null);\n    return uniqueByName(visitor.result);\n  }\n}\n\n// There is a special case of HTML where text that contains a unclosed tag is treated as\n// text. For exaple '<h1> Some <a text </h1>' produces a text nodes inside of the H1\n// element \"Some <a text\". We, however, want to treat this as if the user was requesting\n// the attributes of an \"a\" element, not requesting completion in the a text element. This\n// code checks for this case and returns element completions if it is detected or undefined\n// if it is not.\nfunction voidElementAttributeCompletions(info: TemplateInfo, path: AstPath<HtmlAst>): Completions|\n    undefined {\n  let tail = path.tail;\n  if (tail instanceof Text) {\n    let match = tail.value.match(/<(\\w(\\w|\\d|-)*:)?(\\w(\\w|\\d|-)*)\\s/);\n    // The position must be after the match, otherwise we are still in a place where elements\n    // are expected (such as `<|a` or `<a|`; we only want attributes for `<a |` or after).\n    if (match &&\n        path.position >= (match.index || 0) + match[0].length + tail.sourceSpan.start.offset) {\n      return attributeCompletionsForElement(info, match[3]);\n    }\n  }\n}\n\nclass ExpressionVisitor extends NullTemplateVisitor {\n  private getExpressionScope: () => SymbolTable;\n  result: Completions;\n\n  constructor(\n      private info: TemplateInfo, private position: number, private attr?: Attribute,\n      getExpressionScope?: () => SymbolTable) {\n    super();\n    this.getExpressionScope = getExpressionScope || (() => info.template.members);\n  }\n\n  visitDirectiveProperty(ast: BoundDirectivePropertyAst): void {\n    this.attributeValueCompletions(ast.value);\n  }\n\n  visitElementProperty(ast: BoundElementPropertyAst): void {\n    this.attributeValueCompletions(ast.value);\n  }\n\n  visitEvent(ast: BoundEventAst): void { this.attributeValueCompletions(ast.handler); }\n\n  visitElement(ast: ElementAst): void {\n    if (this.attr && getSelectors(this.info) && this.attr.name.startsWith(TEMPLATE_ATTR_PREFIX)) {\n      // The value is a template expression but the expression AST was not produced when the\n      // TemplateAst was produce so\n      // do that now.\n\n      const key = this.attr.name.substr(TEMPLATE_ATTR_PREFIX.length);\n\n      // Find the selector\n      const selectorInfo = getSelectors(this.info);\n      const selectors = selectorInfo.selectors;\n      const selector =\n          selectors.filter(s => s.attrs.some((attr, i) => i % 2 == 0 && attr == key))[0];\n\n      const templateBindingResult =\n          this.info.expressionParser.parseTemplateBindings(key, this.attr.value, null);\n\n      // find the template binding that contains the position\n      if (!this.attr.valueSpan) return;\n      const valueRelativePosition = this.position - this.attr.valueSpan.start.offset - 1;\n      const bindings = templateBindingResult.templateBindings;\n      const binding =\n          bindings.find(\n              binding => inSpan(valueRelativePosition, binding.span, /* exclusive */ true)) ||\n          bindings.find(binding => inSpan(valueRelativePosition, binding.span));\n\n      const keyCompletions = () => {\n        let keys: string[] = [];\n        if (selector) {\n          const attrNames = selector.attrs.filter((_, i) => i % 2 == 0);\n          keys = attrNames.filter(name => name.startsWith(key) && name != key)\n                     .map(name => lowerName(name.substr(key.length)));\n        }\n        keys.push('let');\n        this.result = keys.map(key => <Completion>{kind: 'key', name: key, sort: key});\n      };\n\n      if (!binding || (binding.key == key && !binding.expression)) {\n        // We are in the root binding. We should return `let` and keys that are left in the\n        // selector.\n        keyCompletions();\n      } else if (binding.keyIsVar) {\n        const equalLocation = this.attr.value.indexOf('=');\n        this.result = [];\n        if (equalLocation >= 0 && valueRelativePosition >= equalLocation) {\n          // We are after the '=' in a let clause. The valid values here are the members of the\n          // template reference's type parameter.\n          const directiveMetadata = selectorInfo.map.get(selector);\n          if (directiveMetadata) {\n            const contextTable =\n                this.info.template.query.getTemplateContext(directiveMetadata.type.reference);\n            if (contextTable) {\n              this.result = this.symbolsToCompletions(contextTable.values());\n            }\n          }\n        } else if (binding.key && valueRelativePosition <= (binding.key.length - key.length)) {\n          keyCompletions();\n        }\n      } else {\n        // If the position is in the expression or after the key or there is no key, return the\n        // expression completions\n        if ((binding.expression && inSpan(valueRelativePosition, binding.expression.ast.span)) ||\n            (binding.key &&\n             valueRelativePosition > binding.span.start + (binding.key.length - key.length)) ||\n            !binding.key) {\n          const span = new ParseSpan(0, this.attr.value.length);\n          this.attributeValueCompletions(\n              binding.expression ? binding.expression.ast :\n                                   new PropertyRead(span, new ImplicitReceiver(span), ''),\n              valueRelativePosition);\n        } else {\n          keyCompletions();\n        }\n      }\n    }\n  }\n\n  visitBoundText(ast: BoundTextAst) {\n    const expressionPosition = this.position - ast.sourceSpan.start.offset;\n    if (inSpan(expressionPosition, ast.value.span)) {\n      const completions = getExpressionCompletions(\n          this.getExpressionScope(), ast.value, expressionPosition, this.info.template.query);\n      if (completions) {\n        this.result = this.symbolsToCompletions(completions);\n      }\n    }\n  }\n\n  private attributeValueCompletions(value: AST, position?: number) {\n    const symbols = getExpressionCompletions(\n        this.getExpressionScope(), value, position == null ? this.attributeValuePosition : position,\n        this.info.template.query);\n    if (symbols) {\n      this.result = this.symbolsToCompletions(symbols);\n    }\n  }\n\n  private symbolsToCompletions(symbols: Symbol[]): Completions {\n    return symbols.filter(s => !s.name.startsWith('__') && s.public)\n        .map(symbol => <Completion>{kind: symbol.kind, name: symbol.name, sort: symbol.name});\n  }\n\n  private get attributeValuePosition() {\n    if (this.attr && this.attr.valueSpan) {\n      return this.position - this.attr.valueSpan.start.offset - 1;\n    }\n    return 0;\n  }\n}\n\nfunction getSourceText(template: TemplateSource, span: Span): string {\n  return template.source.substring(span.start, span.end);\n}\n\nfunction nameOfAttr(attr: AttrInfo): string {\n  let name = attr.name;\n  if (attr.output) {\n    name = removeSuffix(name, 'Events');\n    name = removeSuffix(name, 'Changed');\n  }\n  let result = [name];\n  if (attr.input) {\n    result.unshift('[');\n    result.push(']');\n  }\n  if (attr.output) {\n    result.unshift('(');\n    result.push(')');\n  }\n  if (attr.template) {\n    result.unshift('*');\n  }\n  return result.join('');\n}\n\nconst templateAttr = /^(\\w+:)?(template$|^\\*)/;\nfunction createElementCssSelector(element: Element): CssSelector {\n  const cssSelector = new CssSelector();\n  let elNameNoNs = splitNsName(element.name)[1];\n\n  cssSelector.setElement(elNameNoNs);\n\n  for (let attr of element.attrs) {\n    if (!attr.name.match(templateAttr)) {\n      let [_, attrNameNoNs] = splitNsName(attr.name);\n      cssSelector.addAttribute(attrNameNoNs, attr.value);\n      if (attr.name.toLowerCase() == 'class') {\n        const classes = attr.value.split(/s+/g);\n        classes.forEach(className => cssSelector.addClassName(className));\n      }\n    }\n  }\n  return cssSelector;\n}\n\nfunction foldAttrs(attrs: AttrInfo[]): AttrInfo[] {\n  let inputOutput = new Map<string, AttrInfo>();\n  let templates = new Map<string, AttrInfo>();\n  let result: AttrInfo[] = [];\n  attrs.forEach(attr => {\n    if (attr.fromHtml) {\n      return attr;\n    }\n    if (attr.template) {\n      let duplicate = templates.get(attr.name);\n      if (!duplicate) {\n        result.push({name: attr.name, template: true});\n        templates.set(attr.name, attr);\n      }\n    }\n    if (attr.input || attr.output) {\n      let duplicate = inputOutput.get(attr.name);\n      if (duplicate) {\n        duplicate.input = duplicate.input || attr.input;\n        duplicate.output = duplicate.output || attr.output;\n      } else {\n        let cloneAttr: AttrInfo = {name: attr.name};\n        if (attr.input) cloneAttr.input = true;\n        if (attr.output) cloneAttr.output = true;\n        result.push(cloneAttr);\n        inputOutput.set(attr.name, cloneAttr);\n      }\n    }\n  });\n  return result;\n}\n\nfunction expandedAttr(attr: AttrInfo): AttrInfo[] {\n  if (attr.input && attr.output) {\n    return [\n      attr, {name: attr.name, input: true, output: false},\n      {name: attr.name, input: false, output: true}\n    ];\n  }\n  return [attr];\n}\n\nfunction lowerName(name: string): string {\n  return name && (name[0].toLowerCase() + name.substr(1));\n}\n"]}