{"version":3,"file":"diagnostics.js","sourceRoot":"","sources":["../../../../packages/language-service/src/diagnostics.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAGH,OAAO,EAAyB,gCAAgC,EAAC,MAAM,6CAA6C,CAAC;AAGrH,OAAO,EAA2B,cAAc,EAA4D,MAAM,SAAS,CAAC;AAC5H,OAAO,EAAC,UAAU,EAAE,MAAM,EAAC,MAAM,SAAS,CAAC;AAM3C,MAAM,iCACF,QAAgB,EAAE,WAAwB,EAAE,SAA2B;IACzE,MAAM,OAAO,GAAgB,EAAE,CAAC;IAChC,GAAG,CAAC,CAAC,MAAM,QAAQ,IAAI,SAAS,CAAC,CAAC,CAAC;QACjC,MAAM,GAAG,GAAG,WAAW,CAAC,cAAc,CAAC,QAAQ,EAAE,QAAQ,CAAC,CAAC;QAC3D,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;YACR,EAAE,CAAC,CAAC,GAAG,CAAC,WAAW,IAAI,GAAG,CAAC,WAAW,CAAC,MAAM,CAAC,CAAC,CAAC;gBAC9C,OAAO,CAAC,IAAI,CAAC,GAAG,GAAG,CAAC,WAAW,CAAC,GAAG,CAC/B,CAAC,CAAC,EAAE,CAAC,CAAC;oBACJ,IAAI,EAAE,cAAc,CAAC,KAAK;oBAC1B,IAAI,EAAE,UAAU,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,EAAE,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC;oBACrD,OAAO,EAAE,CAAC,CAAC,GAAG;iBACf,CAAC,CAAC,CAAC,CAAC;YACX,CAAC;YAAC,IAAI,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC,WAAW,IAAI,GAAG,CAAC,OAAO,CAAC,CAAC,CAAC;gBAC1C,MAAM,IAAI,GAA2B;oBACnC,WAAW,EAAE,GAAG,CAAC,WAAW;oBAC5B,OAAO,EAAE,GAAG,CAAC,OAAO;oBACpB,MAAM,EAAE,QAAQ,CAAC,IAAI,CAAC,KAAK;oBAC3B,KAAK,EAAE,QAAQ,CAAC,KAAK;oBACrB,OAAO,EAAE,QAAQ,CAAC,OAAO;iBAC1B,CAAC;gBACF,MAAM,qBAAqB,GAAG,gCAAgC,CAAC,IAAI,CAAC,CAAC;gBACrE,OAAO,CAAC,IAAI,CAAC,GAAG,qBAAqB,CAAC,CAAC;YACzC,CAAC;YACD,EAAE,CAAC,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC;gBACf,OAAO,CAAC,IAAI,CAAC,GAAG,GAAG,CAAC,MAAM,CAAC,GAAG,CAC1B,CAAC,CAAC,EAAE,CAAC,CAAC,EAAC,IAAI,EAAE,CAAC,CAAC,IAAI,EAAE,IAAI,EAAE,CAAC,CAAC,IAAI,IAAI,QAAQ,CAAC,IAAI,EAAE,OAAO,EAAE,CAAC,CAAC,OAAO,EAAC,CAAC,CAAC,CAAC,CAAC;YACjF,CAAC;QACH,CAAC;IACH,CAAC;IACD,MAAM,CAAC,OAAO,CAAC;AACjB,CAAC;AAED,MAAM,oCACF,YAA0B,EAAE,OAA0B;IACxD,MAAM,OAAO,GAAgB,EAAE,CAAC;IAEhC,IAAI,UAAU,GAAgC,SAAS,CAAC;IACxD,GAAG,CAAC,CAAC,MAAM,WAAW,IAAI,YAAY,CAAC,CAAC,CAAC;QACvC,MAAM,MAAM,GAAG,CAAC,OAAwC,EAAE,IAAW,EAAE,EAAE;YACvE,OAAO,CAAC,IAAI,CAAa;gBACvB,IAAI,EAAE,cAAc,CAAC,KAAK;gBAC1B,IAAI,EAAE,IAAI,IAAI,WAAW,CAAC,eAAe,EAAE,OAAO;aACnD,CAAC,CAAC;QACL,CAAC,CAAC;QACF,GAAG,CAAC,CAAC,MAAM,KAAK,IAAI,WAAW,CAAC,MAAM,CAAC,CAAC,CAAC;YACvC,MAAM,CAAC,KAAK,CAAC,OAAO,EAAE,KAAK,CAAC,IAAI,CAAC,CAAC;QACpC,CAAC;QACD,EAAE,CAAC,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC,CAAC;YACzB,EAAE,CAAC,CAAC,WAAW,CAAC,QAAQ,CAAC,WAAW,CAAC,CAAC,CAAC;gBACrC,EAAE,CAAC,CAAC,CAAC,OAAO,CAAC,yBAAyB,CAAC,GAAG,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;oBAC7D,MAAM,CACF,cAAc,WAAW,CAAC,IAAI,CAAC,IAAI,yHAAyH,CAAC,CAAC;gBACpK,CAAC;gBACD,MAAM,EAAC,QAAQ,EAAE,WAAW,EAAC,GAAG,WAAW,CAAC,QAAQ,CAAC,QAAU,CAAC;gBAChE,EAAE,CAAC,CAAC,QAAQ,KAAK,IAAI,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC;oBACtC,MAAM,CAAC,cAAc,WAAW,CAAC,IAAI,CAAC,IAAI,uCAAuC,CAAC,CAAC;gBACrF,CAAC;gBAAC,IAAI,CAAC,EAAE,CAAC,CAAC,QAAQ,IAAI,WAAW,CAAC,CAAC,CAAC;oBACnC,MAAM,CACF,cAAc,WAAW,CAAC,IAAI,CAAC,IAAI,+CAA+C,CAAC,CAAC;gBAC1F,CAAC;YACH,CAAC;YAAC,IAAI,CAAC,CAAC;gBACN,EAAE,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC;oBAChB,UAAU,GAAG,IAAI,GAAG,EAAE,CAAC;oBACvB,OAAO,CAAC,SAAS,CAAC,OAAO,CAAC,MAAM,CAAC,EAAE;wBACjC,MAAM,CAAC,kBAAkB,CAAC,OAAO,CAC7B,SAAS,CAAC,EAAE,GAAG,UAAY,CAAC,GAAG,CAAC,SAAS,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;oBAC/D,CAAC,CAAC,CAAC;gBACL,CAAC;gBACD,EAAE,CAAC,CAAC,CAAC,UAAU,CAAC,GAAG,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;oBACtC,MAAM,CACF,cAAc,WAAW,CAAC,IAAI,CAAC,IAAI,yHAAyH,CAAC,CAAC;gBACpK,CAAC;YACH,CAAC;QACH,CAAC;IACH,CAAC;IAED,MAAM,CAAC,OAAO,CAAC;AACjB,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {NgAnalyzedModules, StaticSymbol} from '@angular/compiler';\nimport {DiagnosticTemplateInfo, getTemplateExpressionDiagnostics} from '@angular/compiler-cli/src/language_services';\n\nimport {AstResult} from './common';\nimport {Declarations, Diagnostic, DiagnosticKind, DiagnosticMessageChain, Diagnostics, Span, TemplateSource} from './types';\nimport {offsetSpan, spanOf} from './utils';\n\nexport interface AstProvider {\n  getTemplateAst(template: TemplateSource, fileName: string): AstResult;\n}\n\nexport function getTemplateDiagnostics(\n    fileName: string, astProvider: AstProvider, templates: TemplateSource[]): Diagnostics {\n  const results: Diagnostics = [];\n  for (const template of templates) {\n    const ast = astProvider.getTemplateAst(template, fileName);\n    if (ast) {\n      if (ast.parseErrors && ast.parseErrors.length) {\n        results.push(...ast.parseErrors.map<Diagnostic>(\n            e => ({\n              kind: DiagnosticKind.Error,\n              span: offsetSpan(spanOf(e.span), template.span.start),\n              message: e.msg\n            })));\n      } else if (ast.templateAst && ast.htmlAst) {\n        const info: DiagnosticTemplateInfo = {\n          templateAst: ast.templateAst,\n          htmlAst: ast.htmlAst,\n          offset: template.span.start,\n          query: template.query,\n          members: template.members\n        };\n        const expressionDiagnostics = getTemplateExpressionDiagnostics(info);\n        results.push(...expressionDiagnostics);\n      }\n      if (ast.errors) {\n        results.push(...ast.errors.map<Diagnostic>(\n            e => ({kind: e.kind, span: e.span || template.span, message: e.message})));\n      }\n    }\n  }\n  return results;\n}\n\nexport function getDeclarationDiagnostics(\n    declarations: Declarations, modules: NgAnalyzedModules): Diagnostics {\n  const results: Diagnostics = [];\n\n  let directives: Set<StaticSymbol>|undefined = undefined;\n  for (const declaration of declarations) {\n    const report = (message: string | DiagnosticMessageChain, span?: Span) => {\n      results.push(<Diagnostic>{\n        kind: DiagnosticKind.Error,\n        span: span || declaration.declarationSpan, message\n      });\n    };\n    for (const error of declaration.errors) {\n      report(error.message, error.span);\n    }\n    if (declaration.metadata) {\n      if (declaration.metadata.isComponent) {\n        if (!modules.ngModuleByPipeOrDirective.has(declaration.type)) {\n          report(\n              `Component '${declaration.type.name}' is not included in a module and will not be available inside a template. Consider adding it to a NgModule declaration`);\n        }\n        const {template, templateUrl} = declaration.metadata.template !;\n        if (template === null && !templateUrl) {\n          report(`Component '${declaration.type.name}' must have a template or templateUrl`);\n        } else if (template && templateUrl) {\n          report(\n              `Component '${declaration.type.name}' must not have both template and templateUrl`);\n        }\n      } else {\n        if (!directives) {\n          directives = new Set();\n          modules.ngModules.forEach(module => {\n            module.declaredDirectives.forEach(\n                directive => { directives !.add(directive.reference); });\n          });\n        }\n        if (!directives.has(declaration.type)) {\n          report(\n              `Directive '${declaration.type.name}' is not included in a module and will not be available inside a template. Consider adding it to a NgModule declaration`);\n        }\n      }\n    }\n  }\n\n  return results;\n}\n"]}